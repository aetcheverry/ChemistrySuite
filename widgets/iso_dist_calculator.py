# -*- coding: utf-8 -*-
"""iso_dist_calculator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qHRXvj1qDvadCkuYSBGegBxw5zgNR1Z6
"""

import math
from PyQt6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QComboBox, QPushButton, QGroupBox, QRadioButton, QButtonGroup,
    QTableWidget, QTableWidgetItem, QHeaderView, QWidget, QCheckBox
)
from PyQt6.QtCore import Qt

from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure

from logic.shared_functions import BaseWidget
from logic import parse_chemical_formula
from logic.isotopes import apply_adduct, convolve_isotopes, peaks_with_charge
from lib import ms_adducts_data


class IsotopicDistCalculator(BaseWidget):
    help_key = "iso_dist_calculator"  # <-- standardized

    def __init__(self, parent=None):
        super().__init__(parent)
        self._is_closing = False
        self.last_dist = None
        self.last_charge = 1
        self.last_adduct_info = None
        self.last_peaks_prob = []
        self.canvas = None
        self.figure = None
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)

        title = QLabel("Isotopic Distribution Calculator")
        f = title.font()
        f.setPointSize(16)
        f.setBold(True)
        title.setFont(f)
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        input_group = QGroupBox("Compound Settings")
        input_layout = QVBoxLayout()

        form_layout = QHBoxLayout()
        self.formula_input = QLineEdit()
        self.formula_input.setPlaceholderText("Enter Chemical Formula (e.g., C10H22N2O)")
        form_layout.addWidget(QLabel("Formula:"))
        form_layout.addWidget(self.formula_input)
        input_layout.addLayout(form_layout)

        mode_layout = QHBoxLayout()
        mode_layout.addWidget(QLabel("Mode:"))
        self.mode_group = QButtonGroup()
        self.rad_pos = QRadioButton("Positive (+)")
        self.rad_neg = QRadioButton("Negative (-)")
        self.rad_pos.setChecked(True)
        self.mode_group.addButton(self.rad_pos)
        self.mode_group.addButton(self.rad_neg)
        mode_layout.addWidget(self.rad_pos)
        mode_layout.addWidget(self.rad_neg)
        mode_layout.addStretch()
        self.mode_group.buttonToggled.connect(self.update_adducts)
        input_layout.addLayout(mode_layout)

        adduct_layout = QHBoxLayout()
        adduct_layout.addWidget(QLabel("Adduct:"))
        self.adduct_combo = QComboBox()
        adduct_layout.addWidget(self.adduct_combo)
        input_layout.addLayout(adduct_layout)

        self.btn_calc = QPushButton("Calculate Distribution")
        self.btn_calc.setStyleSheet("background-color: #3498db; color: white; font-weight: bold; padding: 5px;")
        self.btn_calc.clicked.connect(self.calculate)
        input_layout.addWidget(self.btn_calc)

        input_group.setLayout(input_layout)
        layout.addWidget(input_group)

        self.mono_label = QLabel("Base Peak (100% RI): -")
        self.mono_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        mf = self.mono_label.font()
        mf.setPointSize(12)
        mf.setBold(True)
        self.mono_label.setFont(mf)
        self.mono_label.setStyleSheet(
            "color: #2c3e50; padding: 5px; background-color: #ecf0f1; border-radius: 4px;"
        )
        layout.addWidget(self.mono_label)

        self.table = QTableWidget()
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(["m/z", "Rel. Intensity % (Base=100)", "Delta m/z"])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.setMaximumHeight(200)
        layout.addWidget(self.table)

        btn_row = QHBoxLayout()
        self.btn_copy = QPushButton("Copy Table")
        self.btn_copy.clicked.connect(self.copy_results)
        self.btn_export_plot = QPushButton("Export Plot")
        self.btn_export_plot.clicked.connect(self.export_plot)
        btn_row.addWidget(self.btn_copy)
        btn_row.addWidget(self.btn_export_plot)
        layout.addLayout(btn_row)

        self.figure = Figure(figsize=(5, 4), dpi=100)
        self.canvas = FigureCanvas(self.figure)
        layout.addWidget(self.canvas)

        self.setLayout(layout)
        self.update_adducts()

    # ---- helpers/safety ----
    def _alive(self) -> bool:
        return (not self._is_closing) and (self.canvas is not None) and isinstance(self.canvas, FigureCanvas)

    def safe_show_error(self, title: str, message: str):
        if not self._alive():
            return
        try:
            self.show_error(title, message)
        except Exception:
            pass

    def _fmt3(self, x) -> str:
        try:
            return f"{float(x):.3f}"
        except (ValueError, TypeError):
            return str(x)

    # ---- data population ----
    def update_adducts(self):
        if self._is_closing:
            return
        self.adduct_combo.clear()
        mode = "positive" if self.rad_pos.isChecked() else "negative"
        adducts = ms_adducts_data.ADDUCTS.get(mode, {})
        for key in adducts:
            self.adduct_combo.addItem(key)

    # ---- computation ----
    def calculate(self):
        if not self._alive():
            return
        formula_str = self.formula_input.text()
        if not formula_str:
            self.safe_show_error("Input Error", "Please enter a chemical formula.")
            return
        try:
            base_counts = parse_chemical_formula(formula_str)
        except Exception as e:
            self.safe_show_error("Input Error", f"Invalid formula: {e}")
            return
        if not base_counts:
            self.safe_show_error("Input Error", "Invalid formula.")
            return

        mode = "positive" if self.rad_pos.isChecked() else "negative"
        adduct_name = self.adduct_combo.currentText()
        adduct_info = ms_adducts_data.ADDUCTS.get(mode, {}).get(adduct_name)
        if not adduct_info:
            self.safe_show_error("Input Error", "Please select a valid adduct.")
            return

        try:
            final_counts = apply_adduct(base_counts, mode, adduct_name)
        except ValueError as e:
            self.safe_show_error("Error", str(e))
            return

        if not final_counts or any(n < 0 for n in final_counts.values()):
            self.safe_show_error(
                "Input Error",
                "Adduct produced invalid atom counts (negative or empty). "
                "Please adjust the adduct/mode or formula."
            )
            return

        try:
            dist = convolve_isotopes(final_counts, bin_width=1e-4, prune_threshold=1e-6)
        except Exception as e:
            self.safe_show_error("Computation Error", f"Failed to convolve isotopes: {e}")
            return

        if not dist:
            self.safe_show_error(
                "Computation Error",
                "No isotopic distribution could be computed. "
                "This may happen if the formula contains elements without isotope data "
                "or results in zero total mass. Please check the formula/adduct."
            )
            return

        self.last_adduct_info = adduct_info
        charge = abs(adduct_info.get("charge", 1)) or 1
        mass_offset = 0.0
        try:
            peaks_prob = peaks_with_charge(dist, charge=charge, mass_offset=mass_offset)
        except Exception as e:
            self.safe_show_error("Computation Error", f"Failed to convert to m/z: {e}")
            return

        peaks_prob.sort(key=lambda x: x[0])
        if not peaks_prob:
            self.safe_show_error("Computation Error", "No peaks were generated from the distribution.")
            return

        base_mz, _ = max(peaks_prob, key=lambda x: x[1])
        if self._alive():
            self.mono_label.setText(f"Base Peak (100% RI): {base_mz:.3f} m/z")

        self.last_dist = dist
        self.last_charge = charge
        self.last_peaks_prob = peaks_prob

        self.render_relative_view()

    # ---- rendering ----
    def render_relative_view(self):
        if not self._alive():
            return
        peaks_prob = self.last_peaks_prob or []
        if not peaks_prob:
            return
        max_prob = max(a for _, a in peaks_prob)
        if max_prob <= 0.0:
            self.safe_show_error("Computation Error", "Peaks contain zero intensity.")
            return
        peaks_rel = [(mz, (a / max_prob) * 100.0) for mz, a in peaks_prob]
        self.update_table(peaks_rel)
        self.update_plot(peaks_rel)

    def update_table(self, peaks_rel):
        if not self._alive():
            return
        self.table.clear()
        headers = ["m/z", "Rel. Intensity % (Base=100)", "Delta m/z"]
        self.table.setColumnCount(3)
        self.table.setHorizontalHeaderLabels(headers)
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table.setRowCount(0)
        if not peaks_rel:
            return
        mono_mz = peaks_rel[0][0]
        self.table.setRowCount(len(peaks_rel))
        for i, (mz, rel_int) in enumerate(peaks_rel):
            self.table.setItem(i, 0, QTableWidgetItem(self._fmt3(mz)))
            self.table.setItem(i, 1, QTableWidgetItem(self._fmt3(rel_int)))
            delta = mz - mono_mz
            self.table.setItem(i, 2, QTableWidgetItem(f"{delta:.5f}"))

    def update_plot(self, peaks_rel):
        if not self._alive():
            return
        self.figure.clear()
        ax = self.figure.add_subplot(111)
        if peaks_rel:
            masses = [p[0] for p in peaks_rel]
            yvals = [p[1] for p in peaks_rel]
            markerline, stemlines, baseline = ax.stem(masses, yvals, markerfmt=" ", basefmt="k-")
            if hasattr(stemlines, "set_color"):
                stemlines.set_color("blue")
                if hasattr(stemlines, "set_linewidth"):
                    stemlines.set_linewidth(2.0)
            else:
                try:
                    for ln in stemlines:
                        ln.set_color("blue")
                        ln.set_linewidth(2.0)
                except TypeError:
                    if hasattr(stemlines, "set_color"):
                        stemlines.set_color("blue")
                    if hasattr(stemlines, "set_linewidth"):
                        stemlines.set_linewidth(2.0)
            if hasattr(baseline, "set_color"):
                baseline.set_color("black")
            if hasattr(baseline, "set_linewidth"):
                baseline.set_linewidth(1.0)
            ax.set_xlabel("m/z")
            ax.set_ylabel("Relative Intensity (%)")
            ax.set_title("Predicted Isotopic Pattern (Relative)")
            ax.set_ylim(0, 140)
            ax.set_yticks([0, 20, 40, 60, 80, 100])
            width = masses[-1] - masses[0] if len(masses) > 1 else 1.0
            margin = max(0.02 * width, 0.1)
            ax.set_xlim(masses[0] - margin, masses[-1] + margin)
            ax.grid(True, linestyle='--', alpha=0.6)
            threshold = 5.0
            y_offset = 5.0
            y_top = 139.0
            sorted_by_y = sorted(peaks_rel, key=lambda x: x[1], reverse=True)
            labeled_masses = []
            for mz, y in sorted_by_y:
                if y < threshold:
                    break
                is_obscured = any(abs(mz - m0) <= 0.5 for m0 in labeled_masses)
                if not is_obscured:
                    labeled_masses.append(mz)
                    y_text = min(y + y_offset, y_top)
                    ax.text(mz, y_text, self._fmt3(mz), ha='center', va='bottom', fontsize=8, rotation=90, clip_on=False)
        if self._alive():
            try:
                self.canvas.draw()
            except Exception:
                pass

    def copy_results(self):
        if not self._alive():
            return
        rows = self.table.rowCount()
        cols = self.table.columnCount()
        headers = [self.table.horizontalHeaderItem(i).text() for i in range(cols)]
        text = "\t".join(headers) + "\n"
        for r in range(rows):
            row_data = []
            for c in range(cols):
                item = self.table.item(r, c)
                row_data.append(item.text() if item else "")
            text += "\t".join(row_data) + "\n"
        self.copy_text(text)

    def export_plot(self):
        if self._alive() and hasattr(self, "figure") and self.figure is not None:
            self.export_matplotlib_figure(self.figure)
        else:
            self.safe_show_error("Export Error", "No figure is available to export.")

    def closeEvent(self, event):
        self._is_closing = True

        try:
            self.mode_group.buttonToggled.disconnect(self.update_adducts)
        except Exception:
            pass
        try:
            self.btn_calc.clicked.disconnect(self.calculate)
        except Exception:
            pass
        self.last_dist = None
        self.last_peaks_prob = []
        self.last_adduct_info = None
        try:
            if self.figure is not None:
                try:
                    self.figure.clear()
                except Exception:
                    pass
                try:
                    import matplotlib.pyplot as plt
                    plt.close(self.figure)
                except Exception:
                    pass
        except Exception:
            pass
        try:
            if self.canvas is not None:
                self.canvas.deleteLater()
        except Exception:
            pass
        self.canvas = None
        self.figure = None