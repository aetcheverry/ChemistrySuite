# -*- coding: utf-8 -*-
"""ea_calculator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XJqjKDdrHzUQeB31ykIlqn2s2rWt3iEk
"""

from PyQt6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QGridLayout, QDoubleSpinBox, QComboBox, QPushButton,
    QTextEdit, QGroupBox
)
from PyQt6.QtGui import QFont
from PyQt6.QtCore import Qt

# Shared base class and templating helpers
from logic.shared_functions import (
    BaseWidget,
    build_ea_composition_html,
    build_ea_result_table_html,
    build_ea_full_report_html,
)

# Core formula/composition utilities
from logic import parse_chemical_formula

# Solver (returns best candidate even if outside tolerance)
from logic.ea import find_best_fit

# Data-only module for common solvent formulas
from lib.common_solvents_data import COMMON_SOLVENTS

ELEMENTS_TO_TRACK = ['C', 'H', 'N', 'S', 'O', 'Cl', 'Br', 'I', 'P']


class EACalculator(BaseWidget):
    help_key = "ea_calculator"  # <-- standardized

    def __init__(self):
        super().__init__()
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout()

        # --- 1. Formula Input ---
        formula_group = QGroupBox("Target Compound")
        formula_layout = QHBoxLayout()
        self.formula_input = QLineEdit()
        self.formula_input.setPlaceholderText("Enter Chemical Formula (e.g., C6H3(NO2)2)")
        formula_layout.addWidget(QLabel("Formula:"))
        formula_layout.addWidget(self.formula_input)
        formula_group.setLayout(formula_layout)
        main_layout.addWidget(formula_group)

        # --- 2. Experimental Data (%) ---
        exp_group = QGroupBox("Experimental Data (%)")
        exp_layout = QGridLayout()
        self.exp_inputs = {}

        col_1 = ['C', 'H', 'N']
        col_2 = ['S', 'O']
        col_3 = ['Cl', 'Br', 'I', 'P']

        def add_col(elements, start_col):
            for i, el in enumerate(elements):
                label = QLabel(f"{el}:")
                spin = QDoubleSpinBox()
                spin.setRange(0, 100)
                spin.setDecimals(2)
                spin.setButtonSymbols(QDoubleSpinBox.ButtonSymbols.NoButtons)
                spin.setValue(0)
                spin.clear()
                exp_layout.addWidget(label, i, start_col)
                exp_layout.addWidget(spin, i, start_col + 1)
                self.exp_inputs[el] = spin

        add_col(col_1, 0)
        add_col(col_2, 2)
        add_col(col_3, 4)

        exp_layout.setColumnStretch(1, 1)
        exp_layout.setColumnStretch(3, 1)
        exp_layout.setColumnStretch(5, 1)
        exp_layout.setHorizontalSpacing(20)
        exp_group.setLayout(exp_layout)
        main_layout.addWidget(exp_group)

        # --- 3. Solvents / Impurities ---
        solv_group = QGroupBox("Common Solvents / Impurities")
        solv_layout = QGridLayout()
        self.solvent_rows = []

        solv_layout.addWidget(QLabel("Solvent"), 0, 0)
        solv_layout.addWidget(QLabel("Formula"), 0, 1)
        solv_layout.addWidget(QLabel("Min Mols"), 0, 2)
        solv_layout.addWidget(QLabel("Max Mols"), 0, 3)

        solvent_names = sorted(list(COMMON_SOLVENTS.keys())) + ["Custom"]
        for i in range(5):
            combo = QComboBox()
            combo.addItem("None")
            combo.addItems(solvent_names)

            custom_input = QLineEdit()
            custom_input.setPlaceholderText("Formula")
            custom_input.setEnabled(False)

            min_spin = QDoubleSpinBox()
            min_spin.setRange(0.0, 50.0)
            min_spin.setValue(0.0)
            min_spin.setSingleStep(0.1)
            min_spin.setButtonSymbols(QDoubleSpinBox.ButtonSymbols.UpDownArrows)

            max_spin = QDoubleSpinBox()
            max_spin.setRange(0.0, 50.0)
            max_spin.setValue(3.0)
            max_spin.setSingleStep(0.1)
            max_spin.setButtonSymbols(QDoubleSpinBox.ButtonSymbols.UpDownArrows)

            combo.currentTextChanged.connect(
                lambda text, line_edit=custom_input: self.on_solvent_change(text, line_edit)
            )

            solv_layout.addWidget(combo, i + 1, 0)
            solv_layout.addWidget(custom_input, i + 1, 1)
            solv_layout.addWidget(min_spin, i + 1, 2)
            solv_layout.addWidget(max_spin, i + 1, 3)
            self.solvent_rows.append((combo, custom_input, min_spin, max_spin))

        solv_group.setLayout(solv_layout)
        main_layout.addWidget(solv_group)

        # --- 4. Settings & Calculate ---
        settings_layout = QHBoxLayout()
        self.tol_spin = QDoubleSpinBox()
        self.tol_spin.setRange(0.01, 5.0)
        self.tol_spin.setValue(1.2)  # widened default tolerance for heavy-atom systems
        self.tol_spin.setSingleStep(0.1)
        self.tol_spin.setPrefix("Tolerance: Â±")

        self.inc_spin = QDoubleSpinBox()
        self.inc_spin.setRange(0.01, 1.0)
        self.inc_spin.setValue(0.1)
        self.inc_spin.setSingleStep(0.1)
        self.inc_spin.setPrefix("Increment: ")

        self.calc_btn = QPushButton("Calculate Best Fit")
        font = self.calc_btn.font()
        font.setBold(True)
        self.calc_btn.setFont(font)
        self.calc_btn.setStyleSheet("background-color: #3498db; color: white; font-weight: bold;")
        self.calc_btn.clicked.connect(self.calculate_fit)

        settings_layout.addWidget(self.tol_spin)
        settings_layout.addWidget(self.inc_spin)
        settings_layout.addStretch()
        settings_layout.addWidget(self.calc_btn)
        main_layout.addLayout(settings_layout)

        # --- 5. Results Area ---
        res_group = QGroupBox("Best Match Result")
        res_layout = QVBoxLayout()
        self.results_box = QTextEdit()
        self.results_box.setReadOnly(True)
        self.results_box.setMinimumHeight(150)
        res_font = QFont("Consolas, Monaco, monospace")
        res_font.setStyleHint(QFont.StyleHint.Monospace)
        self.results_box.setFont(res_font)
        res_layout.addWidget(self.results_box)

        copy_res_btn = QPushButton("Copy Results")
        copy_res_btn.clicked.connect(self.copy_results)
        res_layout.addWidget(copy_res_btn)
        res_group.setLayout(res_layout)
        main_layout.addWidget(res_group)

        # --- 6. Report Area ---
        rep_group = QGroupBox("Report")
        rep_layout = QVBoxLayout()
        self.report_box = QTextEdit()
        self.report_box.setReadOnly(True)
        self.report_box.setMaximumHeight(100)
        rep_layout.addWidget(self.report_box)

        copy_rep_btn = QPushButton("Copy Report")
        copy_rep_btn.clicked.connect(self.copy_report)
        rep_layout.addWidget(copy_rep_btn)
        rep_group.setLayout(rep_layout)
        main_layout.addWidget(rep_group)

        self.setLayout(main_layout)

    # --- UI helpers & slots ---
    def on_solvent_change(self, text, line_edit: QLineEdit):
        if text == "Custom":
            line_edit.setEnabled(True)
            line_edit.clear()
            line_edit.setFocus()
        elif text == "None":
            line_edit.setEnabled(False)
            line_edit.clear()
        else:
            line_edit.setEnabled(False)
            if text in COMMON_SOLVENTS:
                line_edit.setText(COMMON_SOLVENTS[text])

    def _experimental_dict(self):
        exp = {}
        for el, spin in self.exp_inputs.items():
            if spin.value() > 0:
                exp[el] = spin.value()
        return exp

    def _build_solvent_specs(self):
        """
        Collect solvent specs for logic.ea.find_best_fit:
        returns list of tuples [(counts_dict, min, max, display_name), ...]
        display_name:
            - Known solvent: its NAME (e.g., "Dimethylformamide")
            - Custom: the TYPED FORMULA (or "Custom" if blank)
        """
        specs = []
        for combo, custom_input, min_spin, max_spin in self.solvent_rows:
            selection = combo.currentText()
            if selection == "None":
                continue

            min_val = float(min_spin.value())
            max_val = float(max_spin.value())

            if selection == "Custom":
                f_str = custom_input.text().strip()
                display = f_str or "Custom"
            else:
                f_str = COMMON_SOLVENTS[selection]
                display = selection

            if not f_str:
                continue

            try:
                counts = parse_chemical_formula(f_str)
                if counts:
                    specs.append((counts, min_val, max_val, display))
            except Exception:
                # Skip invalid custom formulas silently
                pass
        return specs

    def _solvent_list_to_formulas(self, solvents_used):
        """
        Convert a list of (display_name, coeff) into (formula, coeff) by resolving
        known names via COMMON_SOLVENTS. For custom entries the display is already
        the formula string.
        """
        resolved = []
        for name, coeff in solvents_used:
            formula = COMMON_SOLVENTS.get(name, name)  # name is formula for custom
            resolved.append((formula, coeff))
        return resolved

    def calculate_fit(self):
        raw_formula = self.formula_input.text().strip()
        if not raw_formula:
            self.show_error("Error", "Please enter a chemical formula.")
            return

        # Parse main formula
        try:
            main_counts = parse_chemical_formula(raw_formula)
        except Exception as e:
            self.show_error("Error", f"Invalid Formula: {e}")
            return

        experimental = self._experimental_dict()
        if not experimental:
            self.show_error("Error", "Please enter at least one experimental percentage.")
            return

        solvent_specs = self._build_solvent_specs()
        increment = float(self.inc_spin.value())
        tolerance = float(self.tol_spin.value())

        # Solver call: find_best_fit now GUARANTEES a best candidate return
        try:
            result = find_best_fit(
                main_counts=main_counts,
                experimental=experimental,
                solvents=solvent_specs,
                increment=increment,
                tolerance=tolerance,
            )
        except Exception as e:
            self.show_error("Computation Error", f"Best-fit search failed: {e}")
            return

        # Display (templated): composition + results table
        resolved_solvents = self._solvent_list_to_formulas(result.get('solvents_used', []))
        comp_html = build_ea_composition_html(raw_formula, resolved_solvents)
        table_html = build_ea_result_table_html(result['raw_calcs'], experimental, tolerance)
        self.results_box.setHtml(f"<h3 style='margin-bottom:5px;'>Composition: {comp_html}</h3>{table_html}")

        # Full narrative report (templated)
        report_html = build_ea_full_report_html(raw_formula, resolved_solvents, result['raw_calcs'], experimental)
        self.report_box.setHtml(report_html)

    # --- Copy & clear helpers ---
    def copy_results(self):
        self.copy_text(self.results_box.toPlainText())

    def copy_report(self):
        self.copy_text(self.report_box.toPlainText())

    def clear_inputs(self):
        self.formula_input.clear()
        for spin in self.exp_inputs.values():
            spin.setValue(0)
            spin.clear()
        for combo, cust, min_spin, max_spin in self.solvent_rows:
            combo.setCurrentIndex(0)
            cust.clear()
            min_spin.setValue(0.0)
        self.results_box.clear()
        self.report_box.clear()