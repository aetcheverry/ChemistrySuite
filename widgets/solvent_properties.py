# -*- coding: utf-8 -*-
"""solvent_properties

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CUDPVjJelf6YQ8dC16xYpsbKaomXicRv
"""

import re
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem,
    QHeaderView, QLabel, QLineEdit, QHBoxLayout, QApplication,
    QGroupBox, QCheckBox, QComboBox, QGridLayout, QPushButton,
    QStyledItemDelegate, QStyleOptionViewItem, QStyle
)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QTextDocument, QPalette, QFont

from lib import solvent_data  # static dataset module

from logic import solvent_sort_key as solvent_sort_key_fn


class HtmlDelegate(QStyledItemDelegate):
    """
    Paints HTML strings for specific columns (e.g., 'Chemical Formula' and 'Drying Agent').
    Pass a set of column indices to render with QTextDocument (HTML).
    """
    def __init__(self, html_columns: set[int], parent=None):
        super().__init__(parent)
        self.html_columns = set(html_columns)

    def paint(self, painter, option, index):
        if index.column() not in self.html_columns:
            return super().paint(painter, option, index)

        options = QStyleOptionViewItem(option)
        self.initStyleOption(options, index)

        doc = QTextDocument()
        doc.setDefaultFont(options.font)
        doc.setHtml(options.text)

        # Selection colors
        if options.state & QStyle.StateFlag.State_Selected:
            painter.save()
            painter.fillRect(options.rect, options.palette.highlight())
            painter.restore()
            text_color = options.palette.color(QPalette.ColorRole.HighlightedText).name()
        else:
            text_color = options.palette.color(QPalette.ColorRole.Text).name()

        doc.setDefaultStyleSheet(f"body {{ color: {text_color}; }}")

        painter.save()
        painter.translate(options.rect.x(), options.rect.y())
        # Vertical centering
        content_height = doc.size().height()
        if options.rect.height() > content_height:
            offset_y = (options.rect.height() - content_height) / 2
            painter.translate(0, offset_y)
        doc.drawContents(painter)
        painter.restore()

    def sizeHint(self, option, index):
        if index.column() not in self.html_columns:
            return super().sizeHint(option, index)
        doc = QTextDocument()
        doc.setDefaultFont(option.font)
        doc.setHtml(index.data())
        return doc.size().toSize()


class SolventPropertiesWidget(QWidget):
    """Reference table for solvent properties + drying agents."""

    help_key = "solvent_properties"  # F1 -> instructions/solvent_properties_inst.html

    # Column definitions: user-facing title -> key in data dict
    COLUMNS = [
        ("Solvent", "Solvent"),
        ("Chemical Formula", "Chemical Formula"),
        ("Molecular Weight (g/mol)", "Molecular Weight"),
        ("Density (g/mL)", "Density"),
        ("Viscosity (mPa·s)", "Viscosity"),
        ("Vapour Pressure (kPa)", "Vapour Pressure"),
        ("Melting Point (°C)", "Melting Point"),
        ("Boiling Point (°C)", "Boiling Point"),
        ("Flash Point (°C)", "Flash Point"),
        ("UV Cutoff (nm)", "UV Cutoff"),
        ("Refractive Index", "Refractive Index"),
        ("Dielectric Constant", "Dielectric Constant"),
        ("Drying Agent", "Drying Agent"),
    ]

    NUMERIC_KEYS = {
        "Molecular Weight", "Density", "Viscosity", "Vapour Pressure", "Melting Point", "Boiling Point",
        "Flash Point", "UV Cutoff", "Refractive Index", "Dielectric Constant",
    }

    # Preset default visibility (Solvent always visible and no checkbox)
    DEFAULT_VISIBLE_KEYS = {
        "Chemical Formula", "Density", "Boiling Point", "UV Cutoff", "Drying Agent"
    }

    def __init__(self, parent=None):
        super().__init__(parent)
        # Static dataset list baked from Excel file
        self.rows = solvent_data.solvents_list
        # Column checkbox widgets (skip Solvent)
        self.col_checks: list[tuple[int, QCheckBox]] = []
        self._init_ui()

    # --------------------- UI ---------------------
    def _init_ui(self):
        outer = QVBoxLayout(self)
        outer.setContentsMargins(10, 10, 10, 10)

        # Title
        title = QLabel("Solvent Properties")
        font = title.font()
        font.setPointSize(18)
        font.setBold(True)
        title.setFont(font)
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        outer.addWidget(title)

        # Controls: Search + Sorting
        ctrl_row = QHBoxLayout()
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search solvent (e.g., 'Acetone')...")
        self.search_input.textChanged.connect(self._refresh_view)

        self.sort_col = QComboBox()
        self.sort_col.addItems([c[0] for c in self.COLUMNS])

        self.sort_type = QComboBox()
        self.sort_type.addItems(["Alphabetical", "Numeric"])

        self.sort_order = QComboBox()
        self.sort_order.addItems(["Ascending", "Descending"])

        for combo in (self.sort_col, self.sort_type, self.sort_order):
            combo.currentIndexChanged.connect(self._refresh_view)

        ctrl_row.addWidget(QLabel("Search (Solvent):"))
        ctrl_row.addWidget(self.search_input, stretch=1)
        ctrl_row.addSpacing(16)
        ctrl_row.addWidget(QLabel("Sort by:"))
        ctrl_row.addWidget(self.sort_col)
        ctrl_row.addWidget(self.sort_type)
        ctrl_row.addWidget(self.sort_order)
        outer.addLayout(ctrl_row)

        # Column visibility controls (no checkbox for Solvent)
        col_box = QGroupBox("Columns")
        col_grid = QGridLayout()
        self.col_checks = []

        # Build checkboxes for every column except Solvent
        for idx, (title_text, key) in enumerate(self.COLUMNS):
            if key == "Solvent":
                continue  # Solvent is always visible and cannot be hidden
            chk = QCheckBox(title_text)
            chk.setChecked(key in self.DEFAULT_VISIBLE_KEYS)
            chk.stateChanged.connect(self._on_column_visibility_changed)
            pos = len(self.col_checks)
            r = pos // 3
            c = pos % 3
            col_grid.addWidget(chk, r, c)
            self.col_checks.append((idx, chk))  # store after positioning

        # Convenience buttons
        btns_row = QHBoxLayout()
        btn_show_all = QPushButton("Show All")
        btn_hide_all = QPushButton("Hide All (except Solvent)")
        btn_show_all.clicked.connect(lambda: self._set_all_columns(True))
        btn_hide_all.clicked.connect(lambda: self._set_all_columns(False))
        btns_row.addWidget(btn_show_all)
        btns_row.addWidget(btn_hide_all)

        # Total number of checkboxes placed
        total_checks = len(self.col_checks)
        rows_used = (total_checks + 3 - 1) // 3 # ceil(total_checks / 3)
        # Puth the buttons on the next row, spanning all 3 columns

        col_grid.addLayout(btns_row, (len(self.col_checks) // 3) + 1, 0, 1, 3)



        col_box.setLayout(col_grid)
        outer.addWidget(col_box)

        # Table
        self.tree = QTreeWidget()
        self.tree.setColumnCount(len(self.COLUMNS))
        self.tree.setHeaderLabels([c[0] for c in self.COLUMNS])
        header = self.tree.header()
        header.setDefaultAlignment(Qt.AlignmentFlag.AlignCenter)
        not_centered = {"Solvent", "Chemical Formula", "Drying Agent"}

        header_item = self.tree.headerItem()
        for i, (title, key) in enumerate(self.COLUMNS):
            if key in not_centered:
                header_item.setTextAlignment(i, Qt.AlignmentFlag.AlignLeft)
            else:
                header_item.setTextAlignment(i, Qt.AlignmentFlag.AlignCenter)
        self.tree.setAlternatingRowColors(True)
        self.tree.setRootIsDecorated(False)

        # Delegate for HTML columns: Chemical Formula + Drying Agent
        formula_col_index = [i for i, c in enumerate(self.COLUMNS) if c[1] == "Chemical Formula"][0]
        agent_col_index = [i for i, c in enumerate(self.COLUMNS) if c[1] == "Drying Agent"][0]
        html_cols = {formula_col_index, agent_col_index}
        self.tree.setItemDelegate(HtmlDelegate(html_cols, self.tree))

        header = self.tree.header()
        # Allow user resizing; we will fit contents after populate
        for col in range(len(self.COLUMNS)):
            header.setSectionResizeMode(col, QHeaderView.ResizeMode.Interactive)

        outer.addWidget(self.tree)

        # Initial draw
        self._refresh_view()
        # Apply default visibility presets after initial population
        self._apply_default_visibility()
        self._fit_columns()

    # --------------------- Column visibility ---------------------
    def _apply_default_visibility(self):
        """Apply the preset default visibility to all columns (Solvent always visible)."""
        # Hide every column except Solvent and the default-visible keys
        for idx, (title, key) in enumerate(self.COLUMNS):
            if key == "Solvent" or key in self.DEFAULT_VISIBLE_KEYS:
                self.tree.setColumnHidden(idx, False)
            else:
                self.tree.setColumnHidden(idx, True)
        # Synchronize checkboxes with visibility (skip Solvent)
        for idx, chk in self.col_checks:
            key = self.COLUMNS[idx][1]
            chk.setChecked(key in self.DEFAULT_VISIBLE_KEYS)

    def _set_all_columns(self, show: bool):
        """Toggle visibility for all checkbox-controlled columns (Solvent unaffected)."""
        for idx, chk in self.col_checks:
            chk.setChecked(show)

    def _on_column_visibility_changed(self, _state):
        """Respond to individual checkbox toggles, hiding/showing columns."""
        for idx, chk in self.col_checks:
            self.tree.setColumnHidden(idx, not chk.isChecked())
        self._fit_columns()

    # --------------------- Formatting helpers ---------------------
    @staticmethod
    def format_mw_two_decimals(value: float | None) -> str:
        """Display molecular weight with fixed two decimals (e.g., 58.01, 187.38)."""
        if value is None:
            return ""
        try:
            return f"{value:.2f}"
        except Exception:
            return str(value)

    @staticmethod
    def formula_to_html(s: str) -> str:
        """
        Convert plain 'C3H6O' to 'C<sub>3</sub>H<sub>6</sub>O'.
        Subscripts only added to digits that follow letters or closing brackets,
        avoiding standalone numbers in phrases like 'MS 3 Å'.
        """
        if not s:
            return ""
        # Subscript digits that follow a letter or ) ] }
        s = re.sub(r"(?<=[A-Za-z\)\]\}])(\d+)", r"<sub>\1</sub>", s)
        return s

    @staticmethod
    def parse_numeric_for_sort(x: str | float | None) -> float:
        """
        Extract numeric value for sorting (used for text fields such as 'Viscosity').
        """
        if x is None:
            return float("inf")
        if isinstance(x, (int, float)):
            return float(x)
        m = re.search(r"[-+]?[0-9]*\.?[0-9]+", str(x))
        if m:
            try:
                return float(m.group(0))
            except Exception:
                return float("inf")
        return float("inf")

    # --------------------- Data draw ---------------------
    def _refresh_view(self):
        # Filter by solvent only
        query = (self.search_input.text() or "").strip().lower()

        def _is_nonempty_record(r: dict) -> bool:
            return bool(
                (r.get("Solvent") or "").strip()
                or (r.get("Alternative Name") or "").strip()
            )
        def _record_matches_query(r: dict, q: str) -> bool:
            if not q:
                return True
            fields = [
                r.get("Solvent") or "",
                r.get("Alternative Name") or "",
            ]
            return any(q in str(f).lower() for f in fields)

        nonempty = [r for r in self.rows if _is_nonempty_record(r)]
        filtered = [
            r for r in nonempty
            if not query
            or query in (r.get("Solvent") or "").lower()
            or query in (r.get("Alternative Name") or "").lower()
        ]

        # Sort based on controls
        col_idx = self.sort_col.currentIndex()
        col_key = self.COLUMNS[col_idx][1]
        is_numeric = (self.sort_type.currentText() == "Numeric")
        reverse = (self.sort_order.currentText() == "Descending")

        def sort_key_func(r):
            val = r.get(col_key)
            if is_numeric:
                if col_key in self.NUMERIC_KEYS:
                    num = val if isinstance(val, (int, float)) and val is not None else float("inf")
                else:
                    num = self.parse_numeric_for_sort(val)
                return (1, float(num))

            else:
                s = "" if val is None else str(val)
                if col_key == "Solvent":
                    base = solvent_sort_key_fn(s)
                    return (0, base, s.lower())
                return (0, s.lower(), s)

        filtered.sort(key=sort_key_func, reverse=reverse)

        # Populate table
        self.tree.clear()
        for r in filtered:
            visible_keys = [key for (title, key) in self.COLUMNS if key != "Solvent" or True]
            if all(not (str(r.get(k) or "").strip()) for k in visible_keys):
                continue
            item = QTreeWidgetItem(self.tree)
            for i, (title, key) in enumerate(self.COLUMNS):
                val = r.get(key)
                if key == "Chemical Formula":
                    item.setText(i, self.formula_to_html(str(val or "")))
                elif key == "Molecular Weight":
                    item.setText(i, self.format_mw_two_decimals(val))
                elif key == "Drying Agent":
                    # Render potential chemical formulas within the text using subscripts
                    item.setText(i, self.formula_to_html(str(val or "")))
                else:
                    if isinstance(val, float) and val is not None:
                        item.setText(i, str(val))
                    else:
                        item.setText(i, str(val or ""))

                # Center numeric columns for readability
                if key in self.NUMERIC_KEYS:
                    item.setTextAlignment(i, Qt.AlignmentFlag.AlignCenter)

        # Fit widths to contents for visible columns
        self._fit_columns()

    def _fit_columns(self):
        for i in range(len(self.COLUMNS)):
            if not self.tree.isColumnHidden(i):
                self.tree.resizeColumnToContents(i)

    # --------------------- Edit menu compatibility ---------------------
    def clear_inputs(self):
        """Reset search and restore defaults (used by Edit > Clear Inputs)."""
        self.search_input.clear()
        self.sort_col.setCurrentIndex(0)
        self.sort_type.setCurrentIndex(0)   # Alphabetical
        self.sort_order.setCurrentIndex(0)  # Ascending
        # Reset visibility to presets (Solvent always visible)
        self._apply_default_visibility()
        self._refresh_view()

    def copy_results(self):
        """Copy the visible table (all rows currently shown) to clipboard as TSV."""
        cols = self.tree.columnCount()
        visible_idxs = [i for i in range(cols) if not self.tree.isColumnHidden(i)]
        headers = [self.tree.headerItem().text(i) for i in visible_idxs]
        lines = ["\t".join(headers)]
        for i in range(self.tree.topLevelItemCount()):
            item = self.tree.topLevelItem(i)
            row_vals = [item.text(c) for c in visible_idxs]
            lines.append("\t".join(row_vals))
        QApplication.clipboard().setText("\n".join(lines))