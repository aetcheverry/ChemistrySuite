# -*- coding: utf-8 -*-
"""nmr_impurities

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cH0-T0Xf_d0A6Wun6cHfv2NKG_57QAGI
"""

import re
from typing import Dict, List, Optional

from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit,
    QComboBox, QTreeWidget, QTreeWidgetItem, QSizePolicy,
    QHeaderView, QGroupBox, QRadioButton, QButtonGroup, QTextBrowser
)
from PyQt6.QtCore import Qt, QEvent, QTimer

# --- Import NMR & chemistry rich-text formatting ---
from logic import format_notes_richtext_html

# --- Import 1H / 13C data modules (pure-Python) ---
from lib import nmr_1h_data  # DATA_1H, NOTES, REFERENCES
from lib import nmr_13c_data  # DATA_13C, NOTES, REFERENCES

# --- Import NOTES and REFERENCES ---
from lib.nmr_common import NOTES as COMMON_NOTES, REFERENCES as COMMON_RE


class NMRImpuritiesWidget(QWidget):
    """Displays 1H and 13C impurity shifts for deuterated solvents."""

    # Standardised help key so F1 resolves to instructions/nmr_impurities_inst.html
    help_key = "nmr_impurities"

    def __init__(self, parent=None):
        super().__init__(parent)
        self._is_1h = True
        self._solvent_key_map: Dict[str, str] = {}  # display_label -> actual_key

        # Internal: remember indices for policy
        self._imp_col = 0  # "Impurity" column
        self._ref_col: Optional[int] = None  # will be detected by header text

        self.init_ui()

    # ---------------------------------------------------------------------- UI
    def init_ui(self):
        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)

        # Title
        title = QLabel("NMR Solvent Impurities")
        font = title.font()
        font.setPointSize(16)
        font.setBold(True)
        title.setFont(font)
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(title)

        # Controls
        controls_group = QGroupBox("Selection")
        controls_layout = QHBoxLayout()

        self.btn_group_nuc = QButtonGroup()
        self.rad_1h = QRadioButton("1H NMR")
        self.rad_13c = QRadioButton("13C NMR")
        self.rad_1h.setChecked(True)
        self.btn_group_nuc.addButton(self.rad_1h)
        self.btn_group_nuc.addButton(self.rad_13c)

        controls_layout.addWidget(QLabel("Nucleus:"))
        controls_layout.addWidget(self.rad_1h)
        controls_layout.addWidget(self.rad_13c)
        controls_layout.addSpacing(20)

        controls_layout.addWidget(QLabel("Solvent:"))
        self.solvent_combo = QComboBox()
        self.solvent_combo.setMinimumWidth(180)
        controls_layout.addWidget(self.solvent_combo)
        controls_layout.addStretch()

        controls_group.setLayout(controls_layout)
        layout.addWidget(controls_group)

        # Search
        search_layout = QHBoxLayout()
        search_layout.addWidget(QLabel("Search:"))
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText(
            "Name (e.g. Acetone) or Shift (e.g. -4.63 or 1.25)"
        )
        self.search_input.textChanged.connect(self.populate_table)
        search_layout.addWidget(self.search_input)
        layout.addLayout(search_layout)

        # Table
        self.tree = QTreeWidget()
        self.tree.setAlternatingRowColors(True)
        self.tree.setRootIsDecorated(False)

        # Prevent the last column (Ref) from auto-stretching
        hdr = self.tree.header()
        hdr.setStretchLastSection(False)

        layout.addWidget(self.tree)
        layout.setStretch(3, 1)
        layout.setStretch(4, 0)

        # References box
        ref_group = QGroupBox("Notes and References")
        ref_layout = QVBoxLayout()
        self.ref_text = QTextBrowser()
        self.ref_text.setMaximumHeight(120)
        self.ref_text.setSizePolicy(
            QSizePolicy.Policy.Expanding,
            QSizePolicy.Policy.Fixed
        )
        ref_layout.addWidget(self.ref_text)
        ref_group.setLayout(ref_layout)
        layout.addWidget(ref_group)

        self.setLayout(layout)

        # Signals
        self.btn_group_nuc.buttonToggled.connect(self._on_nucleus_toggled)
        self.solvent_combo.currentIndexChanged.connect(self.populate_table)

        # Stretch/resize mechanics
        self.tree.viewport().installEventFilter(self)  # watch viewport resize
        self.tree.header().sectionResized.connect(self._on_section_resized)

        # Initialize
        self.update_solvents()
        self.populate_table()

    # --------------------------------------------------------------- Event hook
    def eventFilter(self, obj, event):
        if obj is self.tree.viewport() and event.type() == QEvent.Type.Resize:
            # Defer to let default layouting finish
            QTimer.singleShot(0, self._stretch_impurity_column)
        return super().eventFilter(obj, event)

    def _on_section_resized(self, logical_index: int, old: int, new: int):
        # When user resizes any non-Impurity column, re-stretch Impurity to fill the rest.
        if logical_index != self._imp_col:
            self._stretch_impurity_column()

    # --------------------------------------------------------------- Solvents
    def _on_nucleus_toggled(self, _btn, _state):
        self._is_1h = self.rad_1h.isChecked()
        self.update_solvents()

    @staticmethod
    def _to_unicode_subscripts(s: str) -> str:
        """
        Replace digits with Unicode subscripts to make chemical formulas display nicely.
        Example: 'CD3CN' -> 'CD₃CN', 'THF-d8' -> 'THF-d₈'
        """
        sub_map = str.maketrans("0123456789", "₀₁₂₃₄₅₆₇₈₉")
        return s.translate(sub_map)

    def update_solvents(self):
        """Populate solvent list based on selected nucleus, with subscripted labels."""
        data_source = (
            getattr(nmr_1h_data, 'DATA_1H', None)
            if self._is_1h
            else getattr(nmr_13c_data, 'DATA_13C', None)
        )

        # Guard: ensure we actually have a dict of solvents
        if not isinstance(data_source, dict) or not data_source:
            self.solvent_combo.blockSignals(True)
            self.solvent_combo.clear()
            self.solvent_combo.blockSignals(False)
            # Show a gentle hint so we notice immediately
            self.ref_text.setHtml("<i>No impurities data found for the selected nucleus.</i>")
            return

        self.solvent_combo.blockSignals(True)
        self.solvent_combo.clear()
        self._solvent_key_map.clear()

        # Populate combo with nice subscript labels
        for key in sorted(data_source.keys()):
            label = self._to_unicode_subscripts(key)
            self.solvent_combo.addItem(label, userData=key)
            self._solvent_key_map[label] = key

        self.solvent_combo.blockSignals(False)

        # Ensure a valid selection so populate_table() gets a solvent
        if self.solvent_combo.count() > 0:
            self.solvent_combo.setCurrentIndex(0)

        # Refresh table
        self.populate_table()

    def _selected_solvent_key(self) -> str:
        """Get the actual solvent key from the combo (using userData)."""
        idx = self.solvent_combo.currentIndex()
        # If no selection yet but items exist, select the first
        if idx < 0 and self.solvent_combo.count() > 0:
            self.solvent_combo.setCurrentIndex(0)
            idx = 0

        if idx >= 0:
            data = self.solvent_combo.itemData(idx)
            if isinstance(data, str) and data:
                return data

        # Fallback to label mapping
        label = self.solvent_combo.currentText()
        return self._solvent_key_map.get(label, label)

    # ------------------------------------------------------------------ Search
    def check_shift_match(
        self, shift_str: str, search_val: float, tolerance: float = 0.03
    ) -> bool:
        """
        Check if a shift string (single value or range) matches a numeric query within tolerance.
        Supports negatives (e.g., '-4.63').
        """
        nums = [float(x) for x in re.findall(r"[+-]?\d+(?:\.\d+)?", shift_str)]
        if not nums:
            return False
        min_shift = min(nums)
        max_shift = max(nums)
        lower_bound = min_shift - tolerance
        upper_bound = max_shift + tolerance
        return lower_bound <= search_val <= upper_bound

    # --------------------------------------------------------------- Populate
    def populate_table(self):
        """Render the table for the selected nucleus and solvent; apply optional search filter."""
        self.tree.clear()
        self.ref_text.clear()

        solvent = self._selected_solvent_key()
        if not solvent:
            return

        # Set headers & alignment per mode

        if self._is_1h:
            # 1H: 6 columns
            self.tree.setColumnCount(6)                           # <<< ensure 6
            self.tree.setHeaderLabels(
                ["Impurity", "Proton", "Mult", "Shift (ppm)", "Notes", "Ref"]
            )
            self._center_header_columns([1, 2, 3, 4, 5])
            data_module = nmr_1h_data
            data_list = getattr(data_module, 'DATA_1H', {}).get(solvent, [])
        else:
            # 13C: 5 columns only
            self.tree.setColumnCount(5)                           # <<< ensure 5
            self.tree.setHeaderLabels(
                ["Impurity", "Carbon", "Shift (ppm)", "Notes", "Ref"]
            )
            self._center_header_columns([1, 2, 3, 4])
            data_module = nmr_13c_data
            data_list = getattr(data_module, 'DATA_13C', {}).get(solvent, [])

        # Determine numeric search
        search_term = self.search_input.text().lower().strip()
        search_shift_val = None
        try:
            if search_term:
                search_shift_val = float(search_term)
        except ValueError:
            pass

        # Filter & sort
        filtered_items: List[dict] = []
        used_refs = set()

        # Sort by compound then shift string
        data_list_sorted = sorted(
            data_list,
            key=lambda x: (x.get('compound', x.get('name', '')), x.get('shift', ''))
        )

        for item in data_list_sorted: # Fixed: Iterate over data_list_sorted
            shift_str = item.get('shift', '')
            name = item.get('compound', item.get('name', ''))
            match = False

            if not search_term:
                match = True
            elif search_shift_val is not None:
                if self.check_shift_match(shift_str, search_shift_val):
                    match = True
            else:
                # Text search in name + proton/carbon if available
                search_target = name
                if self._is_1h and 'proton' in item:
                    search_target += " " + item['proton']
                if (not self._is_1h) and 'carbon' in item:
                    search_target += " " + item['carbon']
                if search_term in search_target.lower():
                    match = True

            if match:
                filtered_items.append(item)

        used_note_codes = set()
        used_ref_keys = set()

        last_name = None
        for item in filtered_items:
            name = item.get('compound', item.get('name', ''))
            shift = item.get('shift', '')
            note = item.get('note', '')
            ref_key = item.get('ref', '')

            display_name = name if name != last_name else ""
            last_name = name

            row = QTreeWidgetItem(self.tree)
            if self._is_1h:
                # 1H: Impurity | Proton | Mult | Shift (ppm) | Notes | Ref
                row.setText(0, display_name)
                row.setText(1, item.get('proton', ''))
                row.setText(2, item.get('mult', ''))
                row.setText(3, shift)
                row.setText(4, note)
                row.setText(5, ref_key)
                # Center-align specified columns
                self._center_row_columns(row, [1, 2, 3, 4, 5])
            else:
                # 13C (5 columns): Impurity | Carbon | Shift (ppm) | Notes | Ref
                row.setText(0, display_name)
                row.setText(1, item.get('carbon', ''))
                row.setText(2, shift)
                row.setText(3, note)
                row.setText(4, ref_key)
                # Center-align specified columns
                self._center_row_columns(row, [1, 2, 3, 4])

            if ref_key:
                used_ref_keys.add(ref_key) # Changed from used_refs

            # Collect visible notes & references for the References box
            for code in self._split_note_codes(note):
                used_note_codes.add(code)

        # Build references/notes panel
        module_notes = getattr(data_module, 'NOTES', {})
        module_references = getattr(data_module, 'REFERENCES', {})

        # Combine module-specific notes/references with common ones
        notes_db = {**COMMON_NOTES, **module_notes}
        references = {**COMMON_RE, **module_references}

        # NOTES section (only those present in the table)
        notes_html = "<b>Notes:</b><br>"
        if used_note_codes:
            for code in sorted(used_note_codes):
                plain = notes_db.get(code, f"(no definition for '{code}')")
                notes_html += f"{code}: {format_notes_richtext_html(plain)}<br>"
        else:
            notes_html += "<i>None</i><br>"

        # REFERENCES section (only those present in the table)
        refs_html = "<br><b>References:</b><br>"
        if used_ref_keys:
            for key in sorted(used_ref_keys):
                full = references.get(key, key)
                refs_html += f"{full}<br>"
        else:
            refs_html += "<i>None</i><br>"

        self.ref_text.setHtml(notes_html + refs_html)

        # Apply per-column sizing policy (Ref fixed-to-contents; Impurity stretches)
        self._apply_column_policies()

    # ----------------------------------------------------------- Header utils
    def _center_header_columns(self, indices: List[int]):
        """Center-align header text for given column indices."""
        header_item = self.tree.headerItem()
        if header_item is None:
            return
        for i in indices:
            header_item.setTextAlignment(i, Qt.AlignmentFlag.AlignCenter)

    def _find_column(self, title: str) -> Optional[int]:
        """Find column index by header text."""
        header_item = self.tree.headerItem()
        if not header_item:
            return None
        target = title.strip().lower()
        for i in range(self.tree.columnCount()):
            if header_item.text(i).strip().lower() == target:
                return i
        return None

    # ------------------------------------------------------------- Row utils
    def _center_row_columns(self, row: QTreeWidgetItem, indices: List[int]):
        """Center-align the given columns in a row item."""
        for i in indices:
            row.setTextAlignment(i, Qt.AlignmentFlag.AlignCenter)

    # ------------------------------------------------------------ Sizing utils

    def _apply_column_policies(self):
        """
        Policy:
          - 'Ref' column: Fixed to its content width.
          - 'Impurity' column (index 0): initialize to content width, then Interactive.
          - All other columns: set to content width, then Interactive.
        """
        header = self.tree.header()
        col_count = self.tree.columnCount()
        if col_count == 0:
            return

        # Resolve 'Ref' column index
        self._ref_col = self._find_column("Ref")

        # 1) Temporarily set non-Impurity columns to ResizeToContents and take their widths
        content_widths = [0] * col_count
        padding = 12  # small extra for aesthetics

        for i in range(col_count):
            # We'll compute widths for *all* columns (including Impurity),
            # but keep Impurity Interactive and just initialize its width
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.ResizeToContents)
            try:
                hint_header = header.sectionSizeHint(i)
            except Exception:
                hint_header = 60
            try:
                hint_view = max(self.tree.sizeHintForColumn(i), 40)
            except Exception:
                hint_view = 60
            content_widths[i] = max(hint_header, hint_view) + padding
            header.resizeSection(i, content_widths[i])

          # 2) 'Ref' column => Fixed (to its content width)
        if self._ref_col is not None:
            ref_w = content_widths[self._ref_col] or 80
            header.setSectionResizeMode(self._ref_col, QHeaderView.ResizeMode.Fixed)
            header.resizeSection(self._ref_col, ref_w)

        # 3) Other non-Impurity, non-Ref columns => Interactive (keep content width)
        for i in range(col_count):
            if i in (self._imp_col, self._ref_col):
                continue
            header.setSectionResizeMode(i, QHeaderView.ResizeMode.Interactive)

        # 4) Impurity => Interactive, initialized to content width (no auto-stretch)
        header.setSectionResizeMode(self._imp_col, QHeaderView.ResizeMode.Interactive)
        self._stretch_impurity_column()

    def _stretch_impurity_column(self):
        """Give the 'Impurity' column the remaining width of the viewport."""
        header = self.tree.header()
        col_count = self.tree.columnCount()
        if col_count == 0:
            return

        viewport_w = self.tree.viewport().width()
        other_sum = 0
        for i in range(col_count):
            if i != self._imp_col:
                other_sum += header.sectionSize(i)

        new_width = max(viewport_w - other_sum - 2, 120)  # keep a sensible min
        # Avoid oscillation: only change if different
        if new_width != header.sectionSize(self._imp_col):
            header.resizeSection(self._imp_col, new_width)

    def _split_note_codes(self, note_field: str) -> List[str]:
        """
        Split a note field like 'b', 'c,g', 'b, n' into ['b'] or ['c','g'].
        Returns [] for empty/None.
        """
        if not note_field:
            return []
        # Split by comma, strip whitespace, drop empties, lowercase
        return [t.strip().lower() for t in note_field.split(',') if t.strip()]