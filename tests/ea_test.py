# -*- coding: utf-8 -*-
"""ea_test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15KhP1oUTGE3rrJxERI5NHQxSLrF0vAfu
"""

from typing import Dict, List, Tuple

import pytest

# Import the EA solver directly (not re-exported in logic/__init__.py)
from logic.ea import find_best_fit

# Import public helpers re-exported by logic/__init__.py
from logic import calculate_elemental_composition


# ---------- Small helpers for the tests ----------


def comp_percentages(counts: Dict[str, float]) -> Dict[str, float]:
    """Return elemental % composition for a stoichiometry dict."""
    return calculate_elemental_composition(counts)


def merge_counts(base: Dict[str, float], adds: List[Tuple[Dict[str, float], float]]) -> Dict[str, float]:
    """
    Combine a base formula with a list of (counts, coefficient) additions.
    Coefficients can be fractional (e.g., 0.5 H2O).
    """
    out = dict(base)
    for counts, c in adds:
        if c == 0:
            continue
        for el, n in counts.items():
            out[el] = out.get(el, 0.0) + n * c
    # Drop zeros/negatives defensively
    out = {k: v for k, v in out.items() if v > 0}
    return out


def approx_dict(d_expected: Dict[str, float], d_got: Dict[str, float], rel=1e-6, abs_tol=1e-6):
    """
    Build a dict of pytest.approx comparators so we can assert dict equality
    with tolerances element-by-element.
    """
    return {k: pytest.approx(d_expected[k], rel=rel, abs=abs_tol) for k in d_expected.keys()}


# ---------- Canonical stoichiometries used across tests ----------

# Base compound from the README examples (common in EA testing)
BASE = {"C": 10, "H": 22, "N": 2, "O": 1}  # C10H22N2O

# Common "solvent/impurity" building blocks
H2O = {"H": 2, "O": 1}
MeOH = {"C": 1, "H": 4, "O": 1}  # CH4O


# ---------- Tests ----------


def test_baseline_composition_is_computed_reasonably():
    """
    Sanity check: composition calculator returns sensible percentages for a
    simple, well-defined formula. (Not tied to EA grid search.)
    """
    # Glucose C6H12O6 as a clean reference point
    glucose = {"C": 6, "H": 12, "O": 6}
    comp = comp_percentages(glucose)

    # Reference values computed from lib.atomic_data (approx):
    # C: ~39.96 %, H: ~6.71 %, O: ~53.33 %
    assert comp["C"] == pytest.approx(39.9, rel=0.01)
    assert comp["H"] == pytest.approx(6.7, rel=0.03)
    assert comp["O"] == pytest.approx(53.3, rel=0.02)
    # Percentages should sum ~100 (within small rounding error)
    assert sum(comp.values()) == pytest.approx(100.0, abs=0.05)


def test_find_best_fit_identifies_half_equiv_water():
    """
    If experimental data exactly match BASE · 0.5 H2O, the solver should find
    0.5 H2O as the best solution when step=0.5 in [0, 1].
    """
    experimental_counts = merge_counts(BASE, [(H2O, 0.5)])
    experimental = comp_percentages(experimental_counts)

    solvents = [
        (H2O, 0.0, 1.0, "H2O"),  # (counts_dict, min, max, display_name)
    ]

    result = find_best_fit(
        main_counts=BASE,
        experimental=experimental,
        solvents=solvents,
        increment=0.5,
        tolerance=0.4,
    )

    # Exact match expected
    assert result["max_diff"] == pytest.approx(0.0, abs=1e-9)
    # Must include a single solvent with 0.5 eq H2O
    assert ("H2O", 0.5) in result["solvents_used"]
    # Raw calculated composition must equal experimental (element-wise approx)
    assert result["raw_calcs"] == approx_dict(experimental, result["raw_calcs"], rel=1e-9, abs_tol=1e-9)


def test_find_best_fit_with_two_solvents_combination():
    """
    If the sample corresponds to BASE · (0.25 H2O) · (0.50 MeOH), the solver
    should recover both coefficients when increment=0.25.
    """
    experimental_counts = merge_counts(BASE, [(H2O, 0.25), (MeOH, 0.50)])
    experimental = comp_percentages(experimental_counts)

    solvents = [
        (H2O, 0.0, 1.0, "H2O"),
        (MeOH, 0.0, 1.0, "MeOH"),
    ]

    result = find_best_fit(
        main_counts=BASE,
        experimental=experimental,
        solvents=solvents,
        increment=0.25,
        tolerance=0.4,
    )

    # Near-exact match expected
    assert result["max_diff"] == pytest.approx(0.0, abs=1e-9)
    assert ("H2O", 0.25) in result["solvents_used"]
    assert ("MeOH", 0.50) in result["solvents_used"]
    # Composition cross-check
    assert result["raw_calcs"] == approx_dict(experimental, result["raw_calcs"], rel=1e-9, abs_tol=1e-9)


def test_zero_increment_returns_baseline():
    """
    Per implementation, increment <= 0 short-circuits to the baseline (unsolvated)
    composition with no solvents selected.
    """
    # Create an experimental that would normally require 0.5 H2O
    experimental = comp_percentages(merge_counts(BASE, [(H2O, 0.5)]))

    solvents = [(H2O, 0.0, 1.0, "H2O")]

    result = find_best_fit(
        main_counts=BASE,
        experimental=experimental,
        solvents=solvents,
        increment=0.0,  # <- special case
        tolerance=0.4,
    )

    baseline = comp_percentages(BASE)

    # With increment <= 0, the function returns baseline directly
    assert result["solvents_used"] == []
    assert result["raw_calcs"] == approx_dict(baseline, result["raw_calcs"])
    # The mismatch is the baseline-vs-experimental difference (non-zero)
    assert result["max_diff"] > 0.0


def test_empty_solvent_list_returns_baseline():
    """
    If no solvents are provided, the function returns the unsolvated baseline.
    """
    experimental = comp_percentages(merge_counts(BASE, [(H2O, 0.5)]))
    result = find_best_fit(
        main_counts=BASE,
        experimental=experimental,
        solvents=[],  # <- no candidates
        increment=0.25,
        tolerance=0.4,
    )

    baseline = comp_percentages(BASE)
    assert result["solvents_used"] == []
    assert result["raw_calcs"] == approx_dict(baseline, result["raw_calcs"])
    assert result["max_diff"] > 0.0


def test_empty_experimental_gives_zero_diff_and_baseline():
    """
    When experimental dict is empty, the internal scorer reports max_diff == 0.0
    and the function returns the baseline composition.
    """
    baseline = comp_percentages(BASE)
    result = find_best_fit(
        main_counts=BASE,
        experimental={},  # <- no found values provided
        solvents=[(H2O, 0.0, 1.0, "H2O")],
        increment=0.25,
        tolerance=0.4,
    )

    assert result["max_diff"] == pytest.approx(0.0, abs=1e-12)
    assert result["solvents_used"] in ([], None)  # typically []
    assert result["raw_calcs"] == approx_dict(baseline, result["raw_calcs"])


def test_best_fit_improves_over_baseline_when_exact_coeff_not_on_grid():
    """
    If the experimental composition corresponds to a non-grid coefficient
    (e.g., 0.33 H2O) and the search step is coarse (e.g., 0.5), the solver
    should still choose the nearest grid point and improve over the baseline.
    """
    # Experimental uses ~0.33 H2O (not representable with step=0.5)
    experimental = comp_percentages(merge_counts(BASE, [(H2O, 1 / 3)]))

    # Baseline mismatch for comparison
    baseline_comp = comp_percentages(BASE)

    # Compute baseline max diff vs experimental for reference (elements present in experimental)
    baseline_max_diff = max(abs(baseline_comp.get(el, 0.0) - val) for el, val in experimental.items())

    result = find_best_fit(
        main_counts=BASE,
        experimental=experimental,
        solvents=[(H2O, 0.0, 1.0, "H2O")],
        increment=0.5,  # coarse grid: {0.0, 0.5, 1.0}
        tolerance=0.4,
    )

    # Solver should pick 0.5 H2O (or 0.0) as the nearest—either way it must improve baseline
    assert result["max_diff"] < baseline_max_diff
    assert result["solvents_used"] in ([("H2O", 0.5)], [])  # improvement implies not empty in practice