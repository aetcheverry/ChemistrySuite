# -*- coding: utf-8 -*-
"""iso_dist_test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13nYnvO_plCVeXgBmQWOkwWkeIu7eXJhQ
"""

from typing import Dict, List, Tuple

import math
import pytest

from logic.isotopes import apply_adduct, convolve_isotopes, peaks_with_charge
from lib import ms_adducts_data


# ----------------------------
# Helpers for assertions
# ----------------------------

def total_percent(dist: List[Tuple[float, float]]) -> float:
    """Sum of % abundance in a (mass, percent) distribution."""
    return sum(a for _, a in dist)


def is_sorted_by_mass(dist: List[Tuple[float, float]]) -> bool:
    """Check non-decreasing order in mass dimension."""
    return all(dist[i][0] <= dist[i + 1][0] for i in range(len(dist) - 1))


def base_peak_index(dist: List[Tuple[float, float]]) -> int:
    """Index of the most intense (base) peak."""
    if not dist:
        return -1
    _, idx = max((a, i) for i, (_, a) in enumerate(dist))
    return idx


# ----------------------------
# Canonical compositions
# ----------------------------

# A small neutral formula that yields multiple isotope peaks
CH4 = {"C": 1, "H": 4}

# A medium-sized organic for adduct tests
C10H22O2 = {"C": 10, "H": 22, "O": 2}

# Single-isotope element (for simple charge test). Sodium has only 23Na at 100%.
Na1 = {"Na": 1}


# ----------------------------
# Tests
# ----------------------------

def test_convolution_normalization_and_sorting_for_ch4():
    """
    convolve_isotopes should:
      - return multiple peaks for CH4 (C has 13C; H has minor 2H)
      - normalize intensities to ~100%
      - sort output by mass (ascending)
      - produce strictly positive percentages
    """
    dist = convolve_isotopes(CH4)  # default bin/prune settings

    assert isinstance(dist, list) and len(dist) > 1, "CH4 should yield multiple isotope peaks"
    assert total_percent(dist) == pytest.approx(100.0, abs=1e-6)
    assert is_sorted_by_mass(dist), "Output must be sorted by mass"
    assert all(0.0 < a <= 100.0 for _, a in dist)


def test_convolution_empty_counts_returns_empty_list():
    """Empty or None-like stoichiometry yields an empty distribution (by design)."""
    assert convolve_isotopes({}) == []


def test_convolution_rejects_non_integer_counts():
    """
    Non-integer stoichiometry (beyond tiny epsilon) is invalid for isotopic convolution
    and must raise a ValueError with a clear message.
    """
    with pytest.raises(ValueError):
        convolve_isotopes({"C": 1.25, "H": 2})


def test_convolution_rejects_unsupported_element():
    """An unknown element symbol must raise ValueError."""
    with pytest.raises(ValueError):
        convolve_isotopes({"Xx": 1})


def test_prune_threshold_can_eliminate_all():
    """
    Using an excessively high prune threshold should prune all intermediate peaks,
    resulting in an empty distribution. (Threshold is applied on FRACTIONS before
    the final 100% normalization.)
    """
    # A single carbon will have ~98.93% at 12C and ~1.07% at 13C (fractions < 1.0),
    # so prune_threshold > 1.0 will drop everything.
    pruned = convolve_isotopes({"C": 1}, prune_threshold=1.1)
    assert pruned == []


def test_apply_adduct_positive_mode_adds_species():
    """
    [M+Na]+ should add one Na atom to the neutral counts and keep others intact.
    """
    updated = apply_adduct(C10H22O2, mode="positive", adduct_name="[M+Na]+")
    # Check stoichiometry change
    assert updated.get("Na", 0) == 1
    # Unchanged core counts (still present; exact values may change if the logic drops zeros)
    for el in ("C", "H", "O"):
        assert updated.get(el, 0.0) > 0.0


def test_apply_adduct_underflow_raises_for_negative_mode():
    """
    [M-H]- subtracts one H. If the base has no H, subtraction would underflow and must raise.
    """
    with pytest.raises(ValueError):
        apply_adduct({"C": 1}, mode="negative", adduct_name="[M-H]-")  # no H to remove


def test_peaks_with_charge_requires_nonzero_charge():
    """Charge = 0 is invalid and must raise ValueError."""
    with pytest.raises(ValueError):
        peaks_with_charge([(10.0, 100.0)], charge=0)


def test_peaks_with_charge_divides_mass_by_charge_for_single_peak():
    """
    With a single-isotope element (Na), the neutral pattern has a single peak.
    For charge z, m/z should be (mass + offset) / |z|.
    Here offset=0 to validate the plain division.
    """
    neutral = convolve_isotopes(Na1)
    assert len(neutral) == 1
    m_neutral, a = neutral[0]
    mz = peaks_with_charge(neutral, charge=2, mass_offset=0.0)
    assert len(mz) == 1
    m_over_z, a2 = mz[0]
    assert a2 == pytest.approx(a, abs=1e-12)
    assert m_over_z == pytest.approx(m_neutral / 2.0, rel=1e-12, abs=1e-12)


def test_adduct_mass_offset_applied_in_mz_space_for_positive_mode():
    """
    For [M+H]+ (charge = +1), the electron mass correction from ms_adducts_data is negative.
    Compare m/z computed with and without the offset — the shift must equal (mass_offset / z).
    """
    # Build adducted composition first (adds +H)
    counts = apply_adduct(C10H22O2, mode="positive", adduct_name="[M+H]+")
    neutral_dist = convolve_isotopes(counts)

    # m/z with and without electron mass offset
    offset = ms_adducts_data.ADDUCTS["positive"]["[M+H]+"]["mass_offset"]
    assert offset < 0.0, "Positive-mode adducts should use a negative electron mass offset"

    mz_no = peaks_with_charge(neutral_dist, charge=1, mass_offset=0.0)
    mz_with = peaks_with_charge(neutral_dist, charge=1, mass_offset=offset)

    # Both lists are sorted by m/z and aligned index-wise
    assert len(mz_no) == len(mz_with) and len(mz_no) > 0

    # Check the base peak (most intense)
    i = base_peak_index(mz_no)
    m0, a0 = mz_no[i]
    m1, a1 = mz_with[i]
    assert a0 == pytest.approx(a1, abs=1e-12)  # offset does not change relative intensities
    assert (m1 - m0) == pytest.approx(offset / 1.0, rel=1e-12, abs=1e-12)


def test_full_pipeline_for_m_plus_h_positive_mode_is_consistent():
    """
    End-to-end check:
      - apply [M+H]+ to counts
      - convolve isotopes
      - convert to m/z for z=1 with the adduct's offset
    Sanity assertions: sorted, normalized intensities, and plausible monoisotopic location.
    """
    counts = apply_adduct(C10H22O2, mode="positive", adduct_name="[M+H]+")
    neutral = convolve_isotopes(counts)
    assert total_percent(neutral) == pytest.approx(100.0, abs=1e-6)
    assert is_sorted_by_mass(neutral)

    offset = ms_adducts_data.ADDUCTS["positive"]["[M+H]+"]["mass_offset"]
    mz = peaks_with_charge(neutral, charge=1, mass_offset=offset)

    # Still sorted and intensities preserved
    assert is_sorted_by_mass(mz)
    assert total_percent(mz) == pytest.approx(100.0, abs=1e-6)

    # Monoisotopic m/z should be close to the minimum m/z in the list
    # (not asserting an exact absolute number—just ordering/shape)
    mono_mz = mz[0][0]
    base_i = base_peak_index(mz)
    assert mono_mz <= mz[base_i][0]  # base peak m/z not below monoisotopic peak


def test_negative_mode_adduct_offset_sign_and_effect():
    """
    Negative mode adducts use a positive electron mass offset (adds +me).
    Validate the sign and its effect on m/z spacing.
    """
    # Use [M-H]- (subtracts one hydrogen)
    counts = apply_adduct(C10H22O2, mode="negative", adduct_name="[M-H]-")
    neutral = convolve_isotopes(counts)

    offset = ms_adducts_data.ADDUCTS["negative"]["[M-H]-"]["mass_offset"]
    assert offset > 0.0, "Negative-mode adducts should use a positive electron mass offset"

    mz_no = peaks_with_charge(neutral, charge=1, mass_offset=0.0)
    mz_with = peaks_with_charge(neutral, charge=1, mass_offset=offset)

    # Check the first (lowest m/z) peak for a consistent positive shift
    assert len(mz_no) == len(mz_with) and len(mz_no) > 0
    delta = mz_with[0][0] - mz_no[0][0]
    assert delta == pytest.approx(offset, rel=1e-12, abs=1e-12)


def test_high_mass_charge_scaling_is_linear():
    """
    For any distribution, the difference between z=1 and z=2 m/z values must be
    consistent with division by |z| (offset kept identical).
    """
    counts = apply_adduct(C10H22O2, mode="positive", adduct_name="[M+Na]+")  # add Na
    neutral = convolve_isotopes(counts)

    offset = ms_adducts_data.ADDUCTS["positive"]["[M+Na]+"]["mass_offset"]
    mz_z1 = peaks_with_charge(neutral, charge=1, mass_offset=offset)
    mz_z2 = peaks_with_charge(neutral, charge=2, mass_offset=offset)

    # Compare first three peaks to be safe
    for k in range(min(3, len(mz_z1))):
        m1, a1 = mz_z1[k]
        m2, a2 = mz_z2[k]
        assert a1 == pytest.approx(a2, abs=1e-12)
        assert m2 == pytest.approx(m1 / 2.0, rel=1e-12, abs=1e-12)