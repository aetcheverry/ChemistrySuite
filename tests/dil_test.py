# -*- coding: utf-8 -*-
"""dil_test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KTfXtmTwSga_B3e3gE0GgZRSZ6uuvaO6
"""

import math
import pytest

from logic.dilution import (
    volume_of_stock_L,
    mass_for_solution_g,
    stock_molarity_from_density_M,
)


# ----------------------------
# C1 V1 = C2 V2 (dilution) tests
# ----------------------------

def test_volume_of_stock_basic_example():
    """
    If you dilute a 2.0 M stock to 0.50 M in a final volume of 1.0 L,
    required V1 = (C2 * V2) / C1 = (0.50 * 1.0) / 2.0 = 0.25 L.
    """
    v1 = volume_of_stock_L(c1_M=2.0, c2_M=0.50, v2_L=1.0)
    assert v1 == pytest.approx(0.25, rel=1e-12, abs=1e-12)


@pytest.mark.parametrize(
    "c1,c2,v2,expected_v1",
    [
        (1.0, 0.1, 1.0, 0.1),         # 1 M -> 0.1 M, 1 L final => 0.1 L stock
        (4.0, 0.5, 0.5, 0.0625),      # 4 M -> 0.5 M, 0.5 L final
        (10.0, 0.01, 2.0, 0.002),     # 10 M -> 0.01 M, 2 L final
        (0.8, 0.2, 0.25, 0.0625),     # 0.8 M -> 0.2 M, 250 mL final
    ],
)
def test_volume_of_stock_parametric(c1, c2, v2, expected_v1):
    v1 = volume_of_stock_L(c1_M=c1, c2_M=c2, v2_L=v2)
    assert v1 == pytest.approx(expected_v1, rel=1e-12, abs=1e-12)


def test_volume_of_stock_rejects_nonpositive_stock():
    with pytest.raises(ValueError):
        volume_of_stock_L(c1_M=0.0, c2_M=0.1, v2_L=1.0)


# ----------------------------
# Mass for solution tests
# ----------------------------

@pytest.mark.parametrize(
    "mw,conc,vol,expected_g",
    [
        # NaCl (58.44 g/mol): 0.10 M, 0.25 L -> 1.461 g
        (58.44, 0.10, 0.25, 58.44 * 0.10 * 0.25),
        # Glucose (180.156 g/mol): 0.50 M, 0.100 L -> 9.0078 g
        (180.156, 0.50, 0.100, 180.156 * 0.50 * 0.100),
        # Caffeine (194.19 g/mol): 0.010 M, 1.000 L -> 1.9419 g
        (194.19, 0.010, 1.000, 194.19 * 0.010 * 1.000),
        # Very dilute case
        (60.0, 1e-6, 2.0, 60.0 * 1e-6 * 2.0),
    ],
)
def test_mass_for_solution_basic(mw, conc, vol, expected_g):
    mass = mass_for_solution_g(mw_g_per_mol=mw, conc_M=conc, vol_L=vol)
    assert mass == pytest.approx(expected_g, rel=1e-12, abs=1e-12)


def test_mass_for_solution_rejects_nonpositive_mw():
    with pytest.raises(ValueError):
        mass_for_solution_g(mw_g_per_mol=0.0, conc_M=0.10, vol_L=1.0)


def test_mass_for_solution_consistency_with_moles():
    """
    mass_for_solution returns g = MW * conc * vol.
    moles = mass / MW should equal conc * vol.
    """
    mw = 180.156  # glucose
    conc = 0.250  # M
    vol = 0.400   # L
    mass_g = mass_for_solution_g(mw_g_per_mol=mw, conc_M=conc, vol_L=vol)
    moles = mass_g / mw
    assert moles == pytest.approx(conc * vol, rel=1e-12, abs=1e-12)


# ----------------------------
# Stock molarity from density tests
# ----------------------------

@pytest.mark.parametrize(
    "density_g_per_mL,purity_wt_frac,mw_g_per_mol,expected_M",
    [
        # Hydrochloric acid ~37% w/w, ρ≈1.19 g/mL, MW=36.46 g/mol -> ~12.08 M
        (1.19, 0.37, 36.46, (1.19 * 1000.0 * 0.37) / 36.46),
        # Sulfuric acid ~98% w/w, ρ≈1.84 g/mL, MW=98.08 g/mol -> ~18.38 M
        (1.84, 0.98, 98.08, (1.84 * 1000.0 * 0.98) / 98.08),
        # Ammonium hydroxide ~28% NH3, ρ≈0.90 g/mL, MW(NH3)=17.03 g/mol -> ~14.8 M (as NH3)
        (0.90, 0.28, 17.03, (0.90 * 1000.0 * 0.28) / 17.03),
    ],
)
def test_stock_molarity_from_density_typical_reagents(density_g_per_mL, purity_wt_frac, mw_g_per_mol, expected_M):
    M = stock_molarity_from_density_M(
        density_g_per_mL=density_g_per_mL,
        purity_wt_frac=purity_wt_frac,
        mw_g_per_mol=mw_g_per_mol,
    )
    # The formula is exactly what the function implements; assert tight equality
    assert M == pytest.approx(expected_M, rel=1e-12, abs=1e-12)


@pytest.mark.parametrize(
    "density,purity,mw",
    [
        (0.0, 0.37, 36.46),
        (1.19, 0.0, 36.46),
        (1.19, 0.37, 0.0),
        (-1.0, 0.37, 36.46),
    ],
)
def test_stock_molarity_from_density_rejects_invalid_inputs(density, purity, mw):
    with pytest.raises(ValueError):
        stock_molarity_from_density_M(density_g_per_mL=density, purity_wt_frac=purity, mw_g_per_mol=mw)


def test_dilution_chain_consistency_using_stock_molarity_and_c1v1():
    """
    Chain check for a liquid stock:
      1) Compute stock molarity M_stock from density/purity/MW.
      2) Choose target (C2, V2) and compute V1 via C1V1=C2V2.
      3) Verify moles taken from stock equal target moles C2 * V2.
    """
    # HCl example
    M_stock = stock_molarity_from_density_M(density_g_per_mL=1.19, purity_wt_frac=0.37, mw_g_per_mol=36.46)
    C2 = 0.100  # M
    V2 = 1.000  # L
    V1 = volume_of_stock_L(c1_M=M_stock, c2_M=C2, v2_L=V2)

    moles_from_stock = M_stock * V1
    target_moles = C2 * V2

    assert moles_from_stock == pytest.approx(target_moles, rel=1e-12, abs=1e-12)


def test_solid_preparation_mass_completes_mole_balance():
    """
    Chain check for a solid:
      mass_for_solution_g returns grams = MW * conc * vol -> moles = grams / MW.
      Verify moles equal conc * vol for several cases.
    """
    for mw, conc, vol in [(58.44, 0.20, 0.50), (180.156, 0.05, 1.00), (100.0, 1e-3, 2.0)]:
        g = mass_for_solution_g(mw_g_per_mol=mw, conc_M=conc, vol_L=vol)
        moles = g / mw
        assert moles == pytest.approx(conc * vol, rel=1e-12, abs=1e-12)