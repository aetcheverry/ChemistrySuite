# -*- coding: utf-8 -*-
"""dosy_test

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_hYkOptK3yV7suDbTwtOw0BkeOM2z5gM
"""

from typing import Tuple

import math
import pytest

from logic.dosy import (
    se_rh_from_D,
    se_D_from_rh,
    segwe_effective_radius_from_MW,
    segwe_f_gw,
    segwe_D,
    segwe_estimate_MW_from_D,
)
from logic.viscosity import viscosity_and_solvent_mw
from logic.constants import KB, PI


# ----------------------------
# Helpers
# ----------------------------

def approx_equal(a: float, b: float, rel: float = 1e-9, abs_tol: float = 1e-12) -> bool:
    """Return True if a ~= b within tolerances."""
    return math.isclose(a, b, rel_tol=rel, abs_tol=abs_tol)


# ----------------------------
# Stokes–Einstein round-trip tests
# ----------------------------

@pytest.mark.parametrize("C_factor", [6.0, 4.0])  # stick (6π), slip (4π)
def test_se_round_trip_D_to_rH_and_back(C_factor: float):
    """
    For given T, η, C, converting D -> rH and back must be consistent.
    """
    T = 298.15             # K
    eta = 1.0e-3           # Pa·s (≈ water at room temp)
    D = 1.0e-9             # m^2/s (typical small molecule scale)

    rH = se_rh_from_D(D_m2_s=D, T_K=T, eta_Pa_s=eta, C_factor=C_factor)
    D_back = se_D_from_rh(rH_m=rH, T_K=T, eta_Pa_s=eta, C_factor=C_factor)

    assert rH > 0.0
    assert approx_equal(D_back, D, rel=5e-12, abs_tol=1e-15)


def test_se_monotonicity_vs_parameters():
    """
    D ∝ T / (C * π * η * rH).
    Check monotonic relationships by varying one parameter at a time.
    """
    T = 298.15
    eta = 1.0e-3
    C = 6.0
    rH = 5.0e-10  # m

    D0 = se_D_from_rh(rH_m=rH, T_K=T, eta_Pa_s=eta, C_factor=C)

    # Increase temperature -> D increases
    D_T_hi = se_D_from_rh(rH_m=rH, T_K=T + 10.0, eta_Pa_s=eta, C_factor=C)
    assert D_T_hi > D0

    # Increase viscosity -> D decreases
    D_eta_hi = se_D_from_rh(rH_m=rH, T_K=T, eta_Pa_s=eta * 10.0, C_factor=C)
    assert D_eta_hi < D0

    # Increase hydrodynamic radius -> D decreases
    D_rH_hi = se_D_from_rh(rH_m=rH * 2.0, T_K=T, eta_Pa_s=eta, C_factor=C)
    assert D_rH_hi < D0

    # Increase C factor (stickier boundary) -> D decreases
    D_C_hi = se_D_from_rh(rH_m=rH, T_K=T, eta_Pa_s=eta, C_factor=C * 1.5)
    assert D_C_hi < D0


def test_se_input_validation_raises():
    """
    Stokes–Einstein helpers must reject non-positive inputs.
    """
    with pytest.raises(ValueError):
        se_rh_from_D(D_m2_s=0.0, T_K=298.15, eta_Pa_s=1e-3, C_factor=6.0)
    with pytest.raises(ValueError):
        se_D_from_rh(rH_m=-1e-9, T_K=298.15, eta_Pa_s=1e-3, C_factor=6.0)
    with pytest.raises(ValueError):
        se_D_from_rh(rH_m=1e-9, T_K=0.0, eta_Pa_s=1e-3, C_factor=6.0)


# ----------------------------
# SEGWE model tests
# ----------------------------

def test_segwe_effective_radius_scales_with_mw():
    """
    r_eff ∝ (MW)^(1/3). Check the ratio between two masses.
    """
    mw1 = 100.0
    mw2 = 800.0
    r1 = segwe_effective_radius_from_MW(mw1)
    r2 = segwe_effective_radius_from_MW(mw2)

    assert r1 > 0.0 and r2 > 0.0
    expected_ratio = (mw2 / mw1) ** (1.0 / 3.0)
    assert approx_equal(r2 / r1, expected_ratio, rel=1e-9)


def test_segwe_effective_radius_input_validation():
    with pytest.raises(ValueError):
        segwe_effective_radius_from_MW(0.0)


def test_segwe_f_gw_monotonic_with_alpha():
    """
    f_gw = (3*alpha)/2 + 1/(1+alpha), alpha = (MW_solv / MW_solute)^(1/3).
    Increasing MW_solv or decreasing MW_solute increases alpha -> increases f_gw.
    """
    MW_solute = 300.0
    f_small_solv = segwe_f_gw(MW_solv_g_per_mol=18.0, MW_solute_g_per_mol=MW_solute)
    f_large_solv = segwe_f_gw(MW_solv_g_per_mol=200.0, MW_solute_g_per_mol=MW_solute)

    assert f_small_solv > 0.0
    assert f_large_solv > f_small_solv

    # Decrease solute MW -> f_gw increases
    f_solute_small = segwe_f_gw(MW_solv_g_per_mol=100.0, MW_solute_g_per_mol=150.0)
    f_solute_large = segwe_f_gw(MW_solv_g_per_mol=100.0, MW_solute_g_per_mol=600.0)
    assert f_solute_small > f_solute_large

    # Validation
    with pytest.raises(ValueError):
        segwe_f_gw(MW_solv_g_per_mol=-10.0, MW_solute_g_per_mol=300.0)
    with pytest.raises(ValueError):
        segwe_f_gw(MW_solv_g_per_mol=100.0, MW_solute_g_per_mol=0.0)


def test_segwe_D_formula_consistency():
    """
    segwe_D returns (D, r_eff). Validate D against the analytical formula:
      D = (kB * T * f_gw) / (6 * π * η * r_eff)
    """
    T = 298.15
    eta = 0.9e-3  # Pa·s
    MW_solvent = 84.17   # e.g., DMSO-d6 MW in data (logic may use other solvent, this is a generic number)
    MW_solute = 250.0

    D, r_eff = segwe_D(T_K=T, eta_Pa_s=eta, MW_solv_g_per_mol=MW_solvent, MW_solute_g_per_mol=MW_solute)
    fgw = segwe_f_gw(MW_solv_g_per_mol=MW_solvent, MW_solute_g_per_mol=MW_solute)

    D_expected = (KB * T * fgw) / (6.0 * PI * eta * r_eff)

    assert r_eff > 0.0 and D > 0.0
    assert approx_equal(D, D_expected, rel=1e-12, abs_tol=1e-15)


def test_segwe_input_validation_raises():
    with pytest.raises(ValueError):
        segwe_D(T_K=0.0, eta_Pa_s=1e-3, MW_solv_g_per_mol=40.0, MW_solute_g_per_mol=300.0)
    with pytest.raises(ValueError):
        segwe_estimate_MW_from_D(T_K=298.15, eta_Pa_s=1e-3, MW_solv_g_per_mol=40.0, target_D_m2_s=0.0)


def test_segwe_estimate_mw_inverts_segwe_D_with_viscosity_integration():
    """
    End-to-end inversion:
      - Use viscosity_and_solvent_mw to get η and MW_solv for a real solvent.
      - Compute D via segwe_D for a chosen solute MW.
      - Invert back via segwe_estimate_MW_from_D and compare.

    We use 'Chloroform-d' (direct entry) at 298 K.
    """
    T = 298.15
    solvent_name = "Chloroform-d"  # present in lib.nmr_solvent_data.SOLVENT_DATA with direct params
    eta, MW_solv = viscosity_and_solvent_mw(solvent_name, T)
    assert eta is not None and MW_solv is not None and eta > 0.0 and MW_solv > 0.0

    MW_true = 350.0  # g/mol (arbitrary test solute)
    D_true, r_eff = segwe_D(T_K=T, eta_Pa_s=eta, MW_solv_g_per_mol=MW_solv, MW_solute_g_per_mol=MW_true)

    MW_est, r_eff_est = segwe_estimate_MW_from_D(
        T_K=T,
        eta_Pa_s=eta,
        MW_solv_g_per_mol=MW_solv,
        target_D_m2_s=D_true,
        low=1.0,
        high=1_000_000.0,
        tol=1e-15,
        max_iter=100,
    )

    # The estimate should recover MW_true very closely
    assert abs(MW_est - MW_true) / MW_true < 1e-6
    assert approx_equal(r_eff_est, r_eff, rel=1e-12, abs_tol=1e-15)


# ----------------------------
# Viscosity helper tests
# ----------------------------

def test_viscosity_direct_entries_positive_values():
    """
    For a direct-entry solvent (e.g., 'Toluene-d8'), viscosity must be positive
    and MW_solv returned as configured.
    """
    T = 298.15
    eta, MW_solv = viscosity_and_solvent_mw("Toluene-d8", T)
    assert eta is not None and MW_solv is not None
    assert eta > 0.0
    assert MW_solv > 0.0


def test_viscosity_inferred_entries_positive_values():
    """
    For an inferred-entry solvent (e.g., 'Ethanol-d6'), viscosity is estimated from
    the non-deuterated reference using MW scaling. Must return positive numbers.
    """
    T = 298.15
    eta, MW_solv = viscosity_and_solvent_mw("Ethanol-d6", T)
    assert eta is not None and MW_solv is not None
    assert eta > 0.0
    assert MW_solv > 0.0


def test_viscosity_unknown_solvent_returns_none():
    """
    Unknown solvent names should return (None, None).
    """
    T = 298.15
    eta, MW_solv = viscosity_and_solvent_mw("Not-A-Real-Solvent", T)
    assert eta is None and MW_solv is None