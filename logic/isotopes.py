# -*- coding: utf-8 -*-
"""isotopes

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IkBwvE4KQeQB-ECcdAG-RxfhHiwwrRiV
"""

from typing import Dict, List, Tuple, Any

from lib import ms_isotopes_data, ms_adducts_data


# ---------------------------------------------------------------------------
# Backward-compatible loader for isotope table
# ---------------------------------------------------------------------------

def _normalize_isotope_entries_from_nested(nested: Dict[Any, Dict[str, float]]) -> List[Tuple[float, float]]:
    """
    Convert nested map {A: {'mass': mA, 'abundance': aA}, ...} to [(mass, fraction), ...]
    and normalize abundances to fractions summing to 1.0.
    """
    pairs: List[Tuple[float, float]] = []
    for _mass_number, rec in nested.items():
        mass = float(rec.get('mass'))
        abund = float(rec.get('abundance'))
        pairs.append((mass, abund))

    if not pairs:
        return []

    total = sum(a for _, a in pairs)
    # Treat as percent if clearly > 1.0
    if total > 1.001:
        pairs = [(m, a / 100.0) for m, a in pairs]
        total = sum(a for _, a in pairs)

    # Final normalization to fraction sum == 1.0
    if total > 0.0:
        pairs = [(m, a / total) for m, a in pairs]
    else:
        pairs = []

    return pairs


def _load_isotopes_table() -> Dict[str, List[Tuple[float, float]]]:
    """
    Obtain the isotope table from lib.ms_isotopes_data.
    Supports multiple attribute names and shapes; normalizes to:
        {element: [(mass, fraction), ...]}
    """
    # Try the actual name used in your file first
    candidates = ("ISOTOPE_DATA", "ISOTOPES", "ISOTOPES_DATA", "ISOTOPES_TABLE", "DATA", "TABLE")
    source = None
    for name in candidates:
        obj = getattr(ms_isotopes_data, name, None)
        if isinstance(obj, dict) and obj:
            source = obj
            break

    if source is None:
        raise AttributeError(
            "ms_isotopes_data does not expose a supported isotope table "
            f"(tried: {', '.join(candidates)})."
        )

    normalized: Dict[str, List[Tuple[float, float]]] = {}

    # Detect nested dict schema (as in ISOTOPE_DATA) vs flat list schema
    for el, payload in source.items():
        if isinstance(payload, dict):
            # Nested: {massNumber: {'mass': ..., 'abundance': ...}}
            normalized[el] = _normalize_isotope_entries_from_nested(payload)
        elif isinstance(payload, list):
            # Already flat list; assume (mass, fraction) or dicts with keys
            flat_pairs: List[Tuple[float, float]] = []
            for entry in payload:
                if isinstance(entry, tuple) and len(entry) >= 2:
                    mass = float(entry[0])
                    abund = float(entry[1])
                    flat_pairs.append((mass, abund))
                elif isinstance(entry, dict):
                    m = entry.get("mass")
                    a = entry.get("abundance", entry.get("fraction", None))
                    if m is not None and a is not None:
                        flat_pairs.append((float(m), float(a)))
            # Normalize as needed
            total = sum(a for _, a in flat_pairs)
            if total > 1.001:
                flat_pairs = [(m, a / 100.0) for m, a in flat_pairs]
                total = sum(a for _, a in flat_pairs)
            normalized[el] = [(m, a / total) for m, a in flat_pairs] if total > 0 else []
        else:
            normalized[el] = []

    return normalized


# Load once at import; keep as module-level constant
try:
    ISOTOPES_TABLE: Dict[str, List[Tuple[float, float]]] = _load_isotopes_table()
except Exception as e:
    ISOTOPES_TABLE = {}
    _ISOTOPES_LOAD_ERROR = e
else:
    _ISOTOPES_LOAD_ERROR = None


# ---------------------------------------------------------------------------
# Adduct application
# ---------------------------------------------------------------------------

def apply_adduct(base_counts: Dict[str, float], mode: str, adduct_name: str) -> Dict[str, float]:
    """
    Apply an adduct to a neutral formula:
        - Adds elements in 'add'
        - Subtracts elements in 'sub'
    Ensures no negative atom counts; raises ValueError if subtraction would underflow.
    """
    adducts_mode = ms_adducts_data.ADDUCTS.get(mode, {})
    info = adducts_mode.get(adduct_name)
    if not info:
        raise ValueError(f"Unknown adduct '{adduct_name}' for mode '{mode}'")

    add = info.get("add", {}) or {}
    sub = info.get("sub", {}) or {}

    new_counts: Dict[str, float] = dict(base_counts)

    # Add first
    for el, n in add.items():
        new_counts[el] = new_counts.get(el, 0.0) + float(n)

    # Subtract next with underflow guard
    for el, n in sub.items():
        new_counts[el] = new_counts.get(el, 0.0) - float(n)
        if new_counts[el] < -1e-12:
            raise ValueError(
                f"Adduct '{adduct_name}' subtraction underflow for element {el} "
                f"(result {new_counts[el]:.6g}). Check formula/adduct."
            )
        # Snap tiny negatives to zero
        if abs(new_counts[el]) < 1e-12:
            new_counts[el] = 0.0

    # Drop zeros and negatives
    for el, n in list(new_counts.items()):
        if n <= 0.0:
            del new_counts[el]

    return new_counts


# ---------------------------------------------------------------------------
# Isotopic convolution
# ---------------------------------------------------------------------------

def _validate_counts_for_isotopes(counts: Dict[str, float]) -> Dict[str, int]:
    """
    Validate counts for isotopic convolution:
      - Elements must exist in ISOTOPES_TABLE
      - Stoichiometry must be non-negative integers (within small epsilon)
    Returns integer counts.
    Raises ValueError with clear messages when invalid.
    """
    if _ISOTOPES_LOAD_ERROR is not None:
        raise ValueError(f"Isotope table load failed: {_ISOTOPES_LOAD_ERROR}")

    if not counts:
        return {}

    int_counts: Dict[str, int] = {}
    for el, n in counts.items():
        if el not in ISOTOPES_TABLE:
            raise ValueError(f"Unsupported element '{el}' in isotopic data.")
        if n < 0:
            raise ValueError(f"Negative stoichiometry for '{el}': {n}")
        # Allow tiny float noise; require near-integer
        n_round = int(round(n))
        if abs(n - n_round) > 1e-6:
            raise ValueError(
                f"Non-integer stoichiometry for '{el}': {n}. "
                f"Isotopic convolution requires integer counts."
            )
        if n_round > 0:
            int_counts[el] = n_round
    return int_counts


def _convolve_two(
    dist: List[Tuple[float, float]],
    iso: List[Tuple[float, float]],
) -> List[Tuple[float, float]]:
    """
    Convolve an existing distribution with one atom's isotopes.
    Inputs:
        dist: [(mass, abundance_fraction)], abundance_fraction in [0,1]
        iso : [(isotope_mass, abundance_fraction)], fractions sum ~1
    Output:
        new distribution [(mass, abundance_fraction)]
    """
    new: Dict[float, float] = {}
    for m0, a0 in dist:
        for mi, ai in iso:
            m = m0 + mi
            a = a0 * ai
            new[m] = new.get(m, 0.0) + a
    return list(new.items())


def _bin_and_prune(
    dist: List[Tuple[float, float]],
    bin_width: float,
    prune_threshold: float,
) -> List[Tuple[float, float]]:
    """
    Bin masses to 'bin_width' and prune entries below 'prune_threshold' (fraction),
    then normalize to 1.0 (fraction).
    """
    if not dist:
        return []

    # Bin by rounding to nearest bin center
    binned: Dict[float, float] = {}
    inv = 1.0 / bin_width
    for m, a in dist:
        key = round(m * inv) / inv
        binned[key] = binned.get(key, 0.0) + a

    # Prune very small fractions
    pruned = [(m, a) for m, a in binned.items() if a >= prune_threshold]
    if not pruned:
        return []

    # Normalize to 1.0 fraction
    total = sum(a for _, a in pruned)
    normed = [(m, a / total) for m, a in pruned]
    # Sort by mass
    normed.sort(key=lambda x: x[0])
    return normed


def convolve_isotopes(
    counts: Dict[str, float],
    bin_width: float = 1e-4,
    prune_threshold: float = 1e-6,
) -> List[Tuple[float, float]]:
    """
    Build isotopic distribution for a neutral formula using convolution.

    Returns list of (mass, percent_abundance), normalized to 100.
    Raises ValueError for unsupported elements or non-integer counts.
    """
    int_counts = _validate_counts_for_isotopes(counts)
    if not int_counts:
        return []

    # Start with a single "zero-mass" unit with full abundance fraction
    dist: List[Tuple[float, float]] = [(0.0, 1.0)]

    # Convolve element by element, atom by atom
    for el, n in int_counts.items():
        iso = ISOTOPES_TABLE[el]  # [(mass, fraction)]
        for _ in range(n):
            dist = _convolve_two(dist, iso)
            dist = _bin_and_prune(dist, bin_width, prune_threshold)
            if not dist:
                # If pruning eliminated all peaks, bail out with empty list
                return []

    # Final normalization to percent scale
    total_fraction = sum(a for _, a in dist)
    if total_fraction <= 0.0:
        return []

    out = [(m, a / total_fraction * 100.0) for m, a in dist]
    out.sort(key=lambda x: x[0])
    return out


# ---------------------------------------------------------------------------
# m/z conversion
# ---------------------------------------------------------------------------

def peaks_with_charge(
    dist: List[Tuple[float, float]],
    charge: int,
    mass_offset: float = 0.0,
) -> List[Tuple[float, float]]:
    """
    Convert neutral isotopic masses to m/z given charge and optional mass_offset.
    - charge: absolute magnitude used for division (must be non-zero).
    - mass_offset: e.g., Â± electron mass from ms_adducts_data.
    """
    if charge == 0:
        raise ValueError("Charge must be non-zero.")
    if not dist:
        return []

    c = float(abs(charge))
    out = [((m + mass_offset) / c, a) for (m, a) in dist]
    out.sort(key=lambda x: x[0])
    return out