# -*- coding: utf-8 -*-
"""shared_functions

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b8jeRIiy1EhprD_UoewPNGA9SPSFD8JN
"""

import os
from typing import Dict, List, Tuple
from PyQt6.QtWidgets import QWidget, QMessageBox, QFileDialog
from PyQt6.QtGui import QGuiApplication, QPalette, QColor
from PyQt6.QtCore import Qt

from typing import Optional
from pathlib import Path

# Optional logic helpers used by EA templating
from logic import format_chemical_formula_html

# --- Help page detection $ alias resolution helpers --------------------------

# Text fragments that positively identify a placeholder page
PLACEHOLDER_MARKERS = (
    "Instructions are not yet available for this module",
    "replace this placeholder with real content",
)

HELP_PAGE_ALIASES = {
    "dilution_calculator_inst.html": "dil_calculator_inst.html"
    # Add more if further mismatches are discovered
}

def _read_text(path: Path) -> Optional[str]:
    try:
        return path.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return None

def _is_placeholder_html(html_text: str) -> bool:
    """Return True if the HTML looks like one of our generated placeholders."""
    low = (html_text or "").lower()

# -----------------------------------------------------------------------------
# Base widget with shared UI helpers
# -----------------------------------------------------------------------------
class BaseWidget(QWidget):
    """
    Base class for all widgets in Chemistry Suite.
    Provides:
      - show_error/copy_text/export_matplotlib_figure
      - standardized help key/filename handling
    """
    # Standardized help key; override per widget.
    # Convention: lower_snake_case short name, e.g., "ea_calculator" -> "ea_calculator_inst.html"
    help_key: str = "main"

    def show_error(self, title: str, message: str):
        """Show a warning dialog. Kept minimal to avoid blocking; caller decides timing."""
        try:
            QMessageBox.warning(self, title, message)
        except Exception:
            # During teardown, widget may be deleted; ignore safely.
            pass

    def copy_text(self, text: str):
        """Copy given plain text to clipboard."""
        try:
            clipboard = QGuiApplication.clipboard()
            clipboard.setText(text)
        except Exception:
            pass

    def export_matplotlib_figure(self, figure):
        """Export a Matplotlib figure to PNG/SVG/PDF via a file dialog."""
        try:
            filters = "PNG (*.png);;SVG (*.svg);;PDF (*.pdf)"
            path, selected_filter = QFileDialog.getSaveFileName(
                self, "Export Plot", "", filters
            )
            if not path:
                return
            # Heuristic: respect selected filter's extension if missing
            sf = (selected_filter or "").lower()
            pl = path.lower()
            if "png" in sf and not pl.endswith(".png"):
                path += ".png"
            elif "svg" in sf and not pl.endswith(".svg"):
                path += ".svg"
            elif "pdf" in sf and not pl.endswith(".pdf"):
                path += ".pdf"
            figure.savefig(path, bbox_inches="tight")
        except Exception as e:
            self.show_error("Export Error", f"Failed to export figure: {e}")

    # ---- Help handling (standardized) ----
    def get_help_filename(self) -> str:
        """Return the standardized help filename for this widget."""
        key = getattr(self, "help_key", "main")
        return f"{key}_inst.html"

    def get_help_title(self) -> str:
        """Return a human-friendly title for the help page (override if needed)."""
        # Basic fallback: Title Case of help_key
        key = getattr(self, "help_key", "main")
        return key.replace("_", " ").title()

# -----------------------------------------------------------------------------
# Palette-aware plot colors
# -----------------------------------------------------------------------------
def _to_hex(color: QColor) -> str:
    return "#{:02x}{:02x}{:02x}".format(color.red(), color.green(), color.blue())

def get_plot_colors() -> Dict[str, str]:
    """
    Return a dictionary of hex colors tuned to the current application palette.
    Keys: 'text', 'grid', 'stem', 'baseline', 'bg'
    """
    app = QGuiApplication.instance()
    pal: QPalette = app.palette() if app else QPalette()

    window = pal.color(QPalette.ColorRole.Window)
    window_text = pal.color(QPalette.ColorRole.WindowText)
    base = pal.color(QPalette.ColorRole.Base)
    text = pal.color(QPalette.ColorRole.Text)
    mid = pal.color(QPalette.ColorRole.Mid)
    highlight = pal.color(QPalette.ColorRole.Highlight)

    # Choose sensible defaults with good contrast in light/dark
    bg_hex = _to_hex(window)
    text_hex = _to_hex(window_text if window_text.isValid() else text)
    grid_hex = _to_hex(mid if mid.isValid() else QColor("#d0d7de"))
    stem_hex = _to_hex(highlight if highlight.isValid() else QColor("#3b82f6"))
    baseline_hex = _to_hex(text if text.isValid() else QColor("#000000"))

    return {
        "text": text_hex,
        "grid": grid_hex,
        "stem": stem_hex,
        "baseline": baseline_hex,
        "bg": bg_hex,
    }

# -----------------------------------------------------------------------------
# EA templating helpers
# -----------------------------------------------------------------------------
def build_ea_composition_html(raw_formula: str, solvents: List[Tuple[str, float]]) -> str:
    """
    Build a 'Formula · coeff SolventFormula' HTML string using logic.format_chemical_formula_html.
    `solvents` is a list of (formula_string, coefficient).
    """
    parts = [format_chemical_formula_html(raw_formula)]
    for formula, coeff in solvents:
        coeff_str = f"{coeff:g}"
        solvent_html = format_chemical_formula_html(formula)
        if coeff_str == "1":
            parts.append(solvent_html)
        else:
            parts.append(f"{coeff_str} {solvent_html}")
    return " · ".join(parts)

def build_ea_result_table_html(
    calc: Dict[str, float],
    experimental: Dict[str, float],
    tolerance: float
) -> str:
    """
    Build an HTML table comparing calculated vs found (%) and diffs.
    Adds a red warning header if the max diff exceeds tolerance.
    """
    diffs = [abs(calc.get(el, 0.0) - found) for el, found in experimental.items()]
    max_diff = max(diffs) if diffs else 0.0

    status_msg = ""
    if max_diff > tolerance:
        status_msg = (
            f" <span style='color:red;'>(Warning: Max Diff "
            f"{max_diff:.2f}% > ±{tolerance}%)</span>"
        )

    # Order: C, H, N first; then others alphabetically
    elements = set(calc.keys()) | set(experimental.keys())
    ordered = []
    for p in ("C", "H", "N"):
        if p in elements:
            ordered.append(p)
            elements.remove(p)
    ordered.extend(sorted(elements))

    rows = []
    for el in ordered:
        cval = calc.get(el, 0.0)
        fval = experimental.get(el, None)
        diff = abs(cval - fval) if fval is not None else None
        fstr = f"{fval:.2f}" if fval is not None else "-"
        dstr = f"{diff:.2f}" if diff is not None else "-"
        rows.append(
            f"<tr>"
            f"<td align='center'><b>{el}</b></td>"
            f"<td align='center'>{cval:.2f}</td>"
            f"<td align='center'>{fstr}</td>"
            f"<td align='center'>{dstr}</td>"
            f"</tr>"
        )

    html = (
        f"<h3 style='margin-bottom:5px;'>Results{status_msg}</h3>"
        f"<table border='1' cellpadding='4' cellspacing='0' "
        f"style='border-collapse:collapse; width:100%;'>"
        f"<tr>"
        f"<th width='15%'>Element</th>"
        f"<th width='28%'>Calculated (%)</th>"
        f"<th width='28%'>Found (%)</th>"
        f"<th width='29%'>Diff (%)</th>"
        f"</tr>"
        f"{''.join(rows)}"
        f"</table>"
    )
    return html

def build_ea_full_report_html(
    raw_formula: str,
    solvents: List[Tuple[str, float]],
    calc: Dict[str, float],
    experimental: Dict[str, float]
) -> str:
    """
    Build a narrative HTML string:
    "Elemental Analysis calculated (%) for <composition>: C, 60.59; H, 4.50; ...; found: C, 60.61; ..."
    """
    comp_html = build_ea_composition_html(raw_formula, solvents)

    keys = set(calc.keys()) | set(experimental.keys())
    ordered = []
    for p in ("C", "H", "N"):
        if p in keys:
            ordered.append(p)
            keys.remove(p)
    ordered.extend(sorted(keys))

    calc_parts = [f"{el}, {calc.get(el, 0.0):.2f}" for el in ordered if el in calc]
    found_parts = [f"{el}, {experimental[el]:.2f}" for el in ordered if el in experimental]

    calc_str = "; ".join(calc_parts)
    found_str = "; ".join(found_parts)

    return (
        f"Elemental Analysis calculated (%) for {comp_html}: "
        f"{calc_str}; found: {found_str}."
    )

# -----------------------------------------------------------------------------
# Help page creation
# -----------------------------------------------------------------------------

def ensure_instruction_page(instructions_dir: str, filename: str, title: str):
    """
    Ensure a help page exists for the given filename under `instructions_dir`.

    Behavior:
      - If the target file exists and is NOT a placeholder -> do nothing.
      - If the target file is missing, or it exists but IS a placeholder:
           * Try to find a rich 'alias' page for this module (see HELP_PAGE_ALIASES).
           * If a rich alias exists, copy its contents into the expected filename.
           * Otherwise, create a minimal placeholder (but never overwrite finalized content).
    """
    try:
        root = Path(instructions_dir)
        root.mkdir(parents=True, exist_ok=True)

        target = root / filename
        target_text = _read_text(target) if target.exists() else None
        target_is_placeholder = _is_placeholder_html(target_text or "") if target_text is not None else True

        # If already present and not a placeholder → done.
        if target.exists() and not target_is_placeholder:
            return

        # Attempt alias upgrade when target is missing or still a placeholder
        alias_name = HELP_PAGE_ALIASES.get(filename)
        if alias_name:
            alias_path = root / alias_name
            if alias_path.exists():
                alias_text = _read_text(alias_path) or ""
                # Only use alias if it looks like a finalized (non-placeholder) page
                if not _is_placeholder_html(alias_text):
                    try:
                        target.write_text(alias_text, encoding="utf-8")
                        return
                    except Exception:
                        # Non-fatal; fall through to placeholder creation.
                        pass

        # Create a placeholder ONLY if we didn't find a finalized page.
        if not target.exists() or _is_placeholder_html(_read_text(target) or ""):
            html = (
                "<!DOCTYPE html>\n"
                "<html lang='en'>\n"
                "<head>\n"
                "  <meta charset='utf-8'>\n"
                f"  <title>{title} — Instructions</title>\n"
                "  <style>"
                "    body{font-family:Segoe UI,Arial,Helvetica,sans-serif;padding:16px;max-width:900px;margin:auto;}"
                "    h1{margin-bottom:0.2em;} .muted{color:#6b7280;} hr{margin:16px 0;}"
                "  </style>\n"
                "</head>\n"
                "<body>\n"
                f"  <h1>{title}</h1>\n"
                "  <div class='muted'>Instructions are not yet available for this module.</div>\n"
                "  <hr/>\n"
                "  <p>You can add a detailed HTML help page for this tool at:</p>\n"
                f"  <code>{filename}</code>\n"
                "  <p>When ready, replace this placeholder with real content.</p>\n"
                "</body>\n"
                "</html>\n"
            )
            try:
                target.write_text(html, encoding="utf-8")
            except Exception:
                # Non-critical: if writing fails, we silently continue.
                pass
    except Exception:
        # Help pages are non-critical; never raise here.
        pass