# -*- coding: utf-8 -*-
"""logic

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U51u40QnveWWVu95jEogeKAK8unTVypl
"""

import re
from typing import Dict, List, Tuple

from lib.atomic_data import ATOMIC_WEIGHTS


# ---------------------------------------------------------------------------
# Formula parsing
# ---------------------------------------------------------------------------
def parse_chemical_formula(formula: str) -> Dict[str, float]:
    """
    Parse a chemical formula into a dictionary of elemental counts.
    Supports nested parentheses and multi-digit counts.

    Examples:
        "C6H6"               -> {"C": 6, "H": 6}
        "C2H5(OH)2"          -> {"C": 2, "H": 7, "O": 2}
        "CH3(CH2)3CH3"       -> {"C": 5, "H": 12}
        "" or None           -> {}

    Notes:
        - Counts are returned as floats to allow subsequent fractional merging.
        - Unknown symbols are not validated here; downstream functions may treat
          unknown elements as zero mass.
    """
    if not formula:
        return {}

    # Remove whitespace to simplify parsing
    s = re.sub(r"\s+", "", formula)

    # Stack of dicts; top of stack is current group
    stack: List[Dict[str, float]] = [dict()]

    i = 0
    n = len(s)

    def add(el: str, cnt: float) -> None:
        if cnt == 0:
            return
        top = stack[-1]
        top[el] = top.get(el, 0.0) + cnt

    while i < n:
        ch = s[i]

        if ch == "(":
            # Start a new subgroup
            stack.append(dict())
            i += 1
            continue

        if ch == ")":
            # Close subgroup; read multiplier (digits following ')')
            i += 1
            j = i
            while j < n and s[j].isdigit():
                j += 1
            mult = float(s[i:j]) if j > i else 1.0

            # Pop subgroup and merge into parent with multiplier
            if len(stack) == 1:
                raise ValueError("Unmatched closing parenthesis in formula.")
            subgroup = stack.pop()
            for el, cnt in subgroup.items():
                add(el, cnt * mult)

            i = j
            continue

        # Element symbol: Uppercase letter followed by optional lowercase letters
        if ch.isupper():
            j = i + 1
            while j < n and s[j].islower():
                j += 1
            el = s[i:j]

            # Optional count (digits) after element
            k = j
            while k < n and s[k].isdigit():
                k += 1
            cnt = float(s[j:k]) if k > j else 1.0

            add(el, cnt)
            i = k
            continue

        # Any other character is unexpected in standard formulas
        raise ValueError(f"Unexpected character '{ch}' at position {i} in formula.")

    if len(stack) != 1:
        # Some groups were never closed
        raise ValueError("Unmatched opening parenthesis in formula.")

    # Drop zero/negative defensively (shouldn't happen here)
    out = {el: cnt for el, cnt in stack[0].items() if cnt > 0}
    return out


# ---------------------------------------------------------------------------
# Molecular weight and composition
# ---------------------------------------------------------------------------
def calculate_molecular_weight(element_counts: Dict[str, float]) -> float:
    """Calculate molecular weight (g/mol) using ATOMIC_WEIGHTS for each element."""
    mw = 0.0
    for el, count in element_counts.items():
        mw += ATOMIC_WEIGHTS.get(el, 0.0) * count
    return mw


def calculate_elemental_composition(element_counts: Dict[str, float]) -> Dict[str, float]:
    """
    Return mass percentages by element for the given composition.
    Unknown elements (not in ATOMIC_WEIGHTS) contribute 0 mass.
    """
    mw = calculate_molecular_weight(element_counts)
    if mw <= 0.0:
        return {}
    comp: Dict[str, float] = {}
    for el, count in element_counts.items():
        mass = ATOMIC_WEIGHTS.get(el, 0.0) * count
        comp[el] = (mass / mw) * 100.0
    return comp


# ---------------------------------------------------------------------------
# Formula merging
# ---------------------------------------------------------------------------
def merge_formulas(main_counts: Dict[str, float], *others: Tuple[Dict[str, float], float]) -> Dict[str, float]:
    """
    Merge multiple count dictionaries into the main composition.

    Parameters
    ----------
    main_counts : dict
        Base elemental counts (e.g., parsed target formula).
    *others : list of (counts_dict, multiplier)
        Each tuple applies 'counts_dict' with a scalar 'multiplier'.

    Returns
    -------
    dict
        Combined elemental counts (floats).
    """
    final: Dict[str, float] = dict(main_counts)
    for counts, multiplier in others:
        if multiplier == 0:
            continue
        for el, ct in counts.items():
            final[el] = final.get(el, 0.0) + ct * multiplier
    # Drop non-positive defensively
    final = {el: ct for el, ct in final.items() if ct > 0.0}
    return final


# ---------------------------------------------------------------------------
# Display helpers
# ---------------------------------------------------------------------------
def format_chemical_formula_html(formula_str: str) -> str:
    """
    Wrap digits in <sub> tags, but ONLY if they follow a letter or ')'
    This prevents leading coefficients (e.g. "2H2O") from being subscripted.
    """
    # Lookbehind assertion: (?<=[a-zA-Z)]) matches a letter or closing paren before the digit
    return re.sub(r"(?<=[a-zA-Z)])(\d+(\.\d+)?)", r"<sub>\1</sub>", formula_str)

def format_composition_string(formula_str: str, solvents_list: List[Tuple[str, float]]) -> str:
    """
    Create a human-readable composition string:
        [formula] · [solvent1] · [coeff solvent2] ...

    - If solvent coefficient == 1, omit the '1' (just the solvent name/formula).
    - Coefficients are rendered with minimal trailing zeros (via :g).
    """
    parts: List[str] = [formula_str]
    for name, coeff in solvents_list:
        if not coeff:
            continue
        coeff_str = f"{coeff:g}"
        if coeff_str == "1":
            parts.append(name)
        else:
            parts.append(f"{coeff_str} {name}")
    return " · ".join(parts)

# --- NMR & chemistry rich-text formatting -----------------------------------

def format_nmr_coupling_html(text: str) -> str:
    """
    Format NMR coupling:
      - nJX,Y  -> <sup>n</sup><i>J</i><sub>X,Y</sub>
      - JX,Y   -> <i>J</i><sub>X,Y</sub>
      - J = x  -> <i>J</i> = x
    It preserves surrounding punctuation/parentheses and units.
    """
    if not text:
        return ""

    # nJX,Y with optional '= value Hz'
    def _repl_nJ(m: re.Match) -> str:
        n       = m.group("n") or ""
        nuclei  = m.group("nuclei") or ""
        nuclei  = re.sub(r"\s+", "", nuclei)
        eq      = m.group("eq") or ""
        val     = m.group("val") or ""
        unit    = m.group("unit") or ""
        sup = f"<sup>{n}</sup>" if n else ""
        sub = f"<sub>{nuclei}</sub>" if nuclei else ""
        core = f"{sup}<i>J</i>{sub}"
        return f"{core} {eq} {val} {unit}".strip()

    text = re.sub(
        r'\b(?P<n>\d+)?J(?P<nuclei>[A-Za-z,\s]+)?(?:\s*(?P<eq>=)\s*(?P<val>\d+(?:\.\d+)?)\s*(?P<unit>Hz))?',
        _repl_nJ,
        text
    )

    # Standalone "J = x Hz" without nuclei
    text = re.sub(r'\bJ\s*=\s*(\d+(?:\.\d+)?)\s*Hz', r'<i>J</i> = \1 Hz', text)
    return text

def format_chemical_inline_html(text: str) -> str:
    """
    Add subscripts in common chemical inline contexts without touching years or 'Hz':
      - Digits embedded within letter sequences: CD3CN -> CD<sub>3</sub>CN
      - Isotopic labels: THF-d8 -> THF-d<sub>8</sub>
      - Group multipliers after a closing bracket: (CD3)2SO -> (CD3)<sub>2</sub>SO
      - Final digits on tokens: CH3 -> CH<sub>3</sub>
    """
    if not text:
        return ""

    # a) Embedded digits between letters: CD3CN -> CD<sub>3</sub>CN
    text = re.sub(r'([A-Za-z])(\d+)(?=[A-Za-z])', r'\1<sub>\2</sub>', text)

    # b) Isotopic 'd' labels: THF-d8 -> THF-d<sub>8</sub>
    text = re.sub(r'-d(\d+)\b', r'-d<sub>\1</sub>', text)

    # c) Group multipliers immediately after a closing parenthesis/bracket:
    #    (CD3)2SO -> (CD3)<sub>2</sub>SO   ;   (CH2)4 -> (CH2)<sub>4</sub>
    text = re.sub(r'([\)\]])(\d+)(?=[A-Za-z])', r'\1<sub>\2</sub>', text)  # before a letter
    text = re.sub(r'([\)\]])(\d+)\b',             r'\1<sub>\2</sub>', text)  # end-of-token

    # d) Final digits on tokens: CH3 -> CH<sub>3</sub>
    text = re.sub(r'([A-Za-z])(\d+)\b', r'\1<sub>\2</sub>', text)


    return text

def format_notes_richtext_html(plain: str) -> str:
    """
    Apply NMR and chemical formatting in order for note strings.
    Keep data dictionaries plain-text; this function produces HTML.
    """
    if not plain:
        return ""
    t = format_nmr_coupling_html(plain)
    t = format_chemical_inline_html(t)
    return t

def solvent_sort_key(name: str) -> str:
    """
    Normalise solvent names for alphabetical sorting by base name.
    Rules:
      - Strip leading numeric locants: e.g., '1-propanol' -> 'propanol',
        '1,2-dichloroethane' -> 'dichloroethane'
      - Strip common prefixes: 'iso-', 'n-', 'm-', 'o-', 'p-'
        e.g., 'iso-butanol' -> 'butanol', 'n-hexane' -> 'hexane', 'm-xylene' -> 'xylene'
      - Lowercase the result and trim spaces/hyphens.
    """
    if not isinstance(name, str):
        name = str(name or "")
    s = name.strip().lower()

    # 1) Remove leading numeric locants (possibly comma-separated), with trailing hyphen
    s = re.sub(r'^[0-9]+(?:,[0-9]+)*[-\s]+', ' ', s)

    # 2) Remove common prefixes (with trailing hyphen/spaces)
    PREFIXES = ('iso', 'n', 'tert', 'm', 'o', 'p')
    s = re.sub(r'^(?:' + '|'.join(PREFIXES) +r')[-\s]+', ' ', s)

    # 3) Collapse extra spaces/hyphens left behind; final trim
    s = re.sub(r'[\s\-]+', ' ', s).strip()
    return s