# -*- coding: utf-8 -*-
"""dosy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GQfsKIrfSKzpQb3xFEIEdfSo0Ya1UxLH
"""

from typing import Tuple
import math
from .constants import KB, PI, NA, RHO_EFF


# --------------------------- Stokes–Einstein (SE) ---------------------------

def se_rh_from_D(D_m2_s: float, T_K: float, eta_Pa_s: float, C_factor: float) -> float:
    """
    Hydrodynamic radius rH (m) from diffusion coefficient D (m^2/s):
        D = kB * T / (C * π * η * rH)  ->  rH = kB * T / (C * π * η * D)
    C_factor: 6.0 (stick/sphere), 4.0 (slip), or user-chosen factor.
    """
    if D_m2_s <= 0 or eta_Pa_s <= 0 or C_factor <= 0 or T_K <= 0:
        raise ValueError("Inputs must be positive.")
    return (KB * T_K) / (C_factor * PI * eta_Pa_s * D_m2_s)


def se_D_from_rh(rH_m: float, T_K: float, eta_Pa_s: float, C_factor: float) -> float:
    """
    Diffusion coefficient D (m^2/s) from hydrodynamic radius rH (m).
    """
    if rH_m <= 0 or eta_Pa_s <= 0 or C_factor <= 0 or T_K <= 0:
        raise ValueError("Inputs must be positive.")
    return (KB * T_K) / (C_factor * PI * eta_Pa_s * rH_m)


# ------------------------------- SEGWE model --------------------------------

def segwe_effective_radius_from_MW(MW_g_per_mol: float) -> float:
    """
    Effective hydrodynamic radius (m) as a function of solute MW (g/mol)
    using the SEGWE sphere-of-equal-volume approximation:
        r_eff = ((3 * MW_kg) / (4 * π * ρ_eff * N_A))^(1/3)
    """
    if MW_g_per_mol <= 0:
        raise ValueError("MW must be positive.")
    MW_kg = MW_g_per_mol / 1000.0
    term = (3.0 * MW_kg) / (4.0 * PI * RHO_EFF * NA)
    return term ** (1.0 / 3.0)


def segwe_f_gw(MW_solv_g_per_mol: float, MW_solute_g_per_mol: float) -> float:
    """
    Gorin–Wertz empirical correction factor used in SEGWE:
        alpha = (MW_s / MW)^1/3
        f_gw  = (3*alpha)/2 + 1/(1+alpha)
    """
    if MW_solv_g_per_mol <= 0 or MW_solute_g_per_mol <= 0:
        raise ValueError("MWs must be positive.")
    alpha = (MW_solv_g_per_mol / MW_solute_g_per_mol) ** (1.0 / 3.0)
    return (3.0 * alpha) / 2.0 + 1.0 / (1.0 + alpha)


def segwe_D(T_K: float, eta_Pa_s: float,
            MW_solv_g_per_mol: float, MW_solute_g_per_mol: float) -> Tuple[float, float]:
    """
    Compute (D_m2_s, r_eff_m) for given conditions using SEGWE-adjusted SE:
        D = (kB * T * f_gw) / (6 * π * η * r_eff)
    Returns: (D in m^2/s, r_eff in m)
    """
    if T_K <= 0 or eta_Pa_s <= 0:
        raise ValueError("T and η must be positive.")

    r_eff = segwe_effective_radius_from_MW(MW_solute_g_per_mol)
    fgw = segwe_f_gw(MW_solv_g_per_mol, MW_solute_g_per_mol)
    D = (KB * T_K * fgw) / (6.0 * PI * eta_Pa_s * r_eff)
    return D, r_eff


def segwe_estimate_MW_from_D(T_K: float, eta_Pa_s: float, MW_solv_g_per_mol: float,
                             target_D_m2_s: float,
                             low: float = 1.0, high: float = 1_000_000.0,
                             tol: float = 1e-15, max_iter: int = 100) -> Tuple[float, float]:
    """
    Invert SEGWE to estimate solute MW from target diffusion coefficient.
    Returns: (estimated_MW_g_per_mol, r_eff_m)
    """
    if target_D_m2_s <= 0:
        raise ValueError("Target D must be positive.")

    lo, hi = low, high
    mid = (lo + hi) / 2.0
    for _ in range(max_iter):
        mid = (lo + hi) / 2.0
        D_mid, _ = segwe_D(T_K, eta_Pa_s, MW_solv_g_per_mol, mid)
        if abs(D_mid - target_D_m2_s) < tol or (hi - lo) < 1e-6:
            break
        # Note: D decreases as MW increases, so the logic here is inverted compared to standard search
        if D_mid > target_D_m2_s:
            lo = mid  # Need higher MW to decrease D
        else:
            hi = mid  # Need lower MW to increase D

    # Final values
    _, r_eff = segwe_D(T_K, eta_Pa_s, MW_solv_g_per_mol, mid)

    return mid, r_eff