# -*- coding: utf-8 -*-
"""ea

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vSx2qJfWIDGVhncNfqgfqFnyS0OVi5h7
"""

from itertools import product
from typing import Dict, List, Tuple

from logic import calculate_elemental_composition, format_composition_string


def _score_max_diff(calc: Dict[str, float], experimental: Dict[str, float]) -> float:
    """
    Return the max absolute difference (in %) between calculated and experimental
    values over the experimental elements only.
    """
    if not experimental:
        return 0.0
    diffs = []
    for el, found in experimental.items():
        diffs.append(abs(calc.get(el, 0.0) - found))
    return max(diffs) if diffs else 0.0


def _frange(min_val: float, max_val: float, step: float) -> List[float]:
    """
    Inclusive float range for grid search. Uses a small epsilon to include max.
    """
    vals: List[float] = []
    v = float(min_val)
    eps = 1e-9
    while v <= max_val + eps:
        vals.append(round(v, 10))
        v += step
    return vals


def _merge_counts(
    main: Dict[str, float],
    solvents: List[Tuple[Dict[str, float], float, float, str]],
    coeffs: List[float],
) -> Dict[str, float]:
    """
    Merge base counts with solvent contributions:
        combined[element] = main[element] + sum(coeff * counts[element]).
    Drops non-positive totals defensively.
    """
    combined: Dict[str, float] = dict(main)
    for (counts, _min, _max, _disp), c in zip(solvents, coeffs):
        if c <= 0.0:
            continue
        for el, stoich in counts.items():
            combined[el] = combined.get(el, 0.0) + (stoich * c)
    for el, tot in list(combined.items()):
        if tot <= 0.0:
            del combined[el]
    return combined


def find_best_fit(
    main_counts: Dict[str, float],
    experimental: Dict[str, float],
    solvents: List[Tuple[Dict[str, float], float, float, str]],
    increment: float = 0.1,
    tolerance: float = 0.4,
) -> Dict:
    """
    Search the solvent space and return the BEST candidate found.
    Always returns a dict (see module docstring), even if outside tolerance.

    Parameters
    ----------
    main_counts : dict
        Base stoichiometric counts of the target formula.
    experimental : dict
        Experimental mass percentages by element (subset of elements).
    solvents : list of tuples
        Each: (counts_dict, min_mols, max_mols, display_name)
    increment : float
        Step for grid search over solvent coefficients.
    tolerance : float
        Desired maximum difference threshold (used for warnings in UI).

    Returns
    -------
    dict
        Best candidate.
    """
    # Baseline (unsolvated)
    base_comp = calculate_elemental_composition(main_counts)
    best = {
        "raw_calcs": base_comp,
        "max_diff": _score_max_diff(base_comp, experimental),
        "solvents_used": [],
        # UI will prepend raw formula; here we include only solvents for clarity.
        "composition_html": format_composition_string("", []),
    }

    if not solvents or increment <= 0.0:
        return best

    grids = [_frange(min_m, max_m, increment) for (_cnt, min_m, max_m, _disp) in solvents]
    if any(len(g) == 0 for g in grids):
        return best

    # Exhaustive grid search (up to 5 solvents in UI â†’ tractable for modest ranges)
    for coeffs in product(*grids):
        combined_counts = _merge_counts(main_counts, solvents, list(coeffs))
        if not combined_counts:
            continue

        calc_comp = calculate_elemental_composition(combined_counts)
        max_diff = _score_max_diff(calc_comp, experimental)

        # Global best by minimum max_diff
        if max_diff < best["max_diff"] - 1e-12:
            best["raw_calcs"] = calc_comp
            best["max_diff"] = max_diff
            best["solvents_used"] = [
                (solvents[i][3], c) for i, c in enumerate(coeffs) if c > 0.0
            ]
            best["composition_html"] = format_composition_string("", best["solvents_used"])

            # Optional early-exit:
            # if max_diff <= tolerance: break

    return best


# =========================================
# File: logic/isotopes.py
# =========================================
# -*- coding: utf-8 -*-
"""
logic/isotopes.py
Mass spectrometry helpers:
- apply_adduct: modify elemental counts by adduct (add/sub).
- convolve_isotopes: build isotopic distribution for a neutral formula.
- peaks_with_charge: convert neutral masses to m/z for a given charge.

This module is hardened to NEVER return None:
- convolve_isotopes returns [] on empty/invalid input or raises ValueError with
  a clear message (preferred for unsupported elements / non-integer stoichiometry).
"""

from typing import Dict, List, Tuple

from lib import ms_isotopes_data, ms_adducts_data


def apply_adduct(base_counts: Dict[str, float], mode: str, adduct_name: str) -> Dict[str, float]:
    """
    Apply an adduct to a neutral formula:
        - Adds elements in 'add'
        - Subtracts elements in 'sub'
    Ensures no negative atom counts; raises ValueError if subtraction would underflow.

    Parameters
    ----------
    base_counts : dict
        Elemental counts of neutral formula, e.g. {'C': 10, 'H': 22, 'O': 2}
    mode : str
        'positive' or 'negative'
    adduct_name : str
        Key in ms_adducts_data.ADDUCTS[mode]

    Returns
    -------
    dict
        New counts after adduct.

    Raises
    ------
    ValueError
        If adduct is unknown or produces negative counts.
    """
    adducts_mode = ms_adducts_data.ADDUCTS.get(mode, {})
    info = adducts_mode.get(adduct_name)
    if not info:
        raise ValueError(f"Unknown adduct '{adduct_name}' for mode '{mode}'")

    add = info.get("add", {}) or {}
    sub = info.get("sub", {}) or {}

    new_counts: Dict[str, float] = dict(base_counts)

    # Add first
    for el, n in add.items():
        new_counts[el] = new_counts.get(el, 0.0) + float(n)

    # Subtract next with underflow guard
    for el, n in sub.items():
        new_counts[el] = new_counts.get(el, 0.0) - float(n)
        if new_counts[el] < -1e-12:
            raise ValueError(
                f"Adduct '{adduct_name}' subtraction underflow for element {el} "
                f"(result {new_counts[el]:.6g}). Check formula/adduct."
            )
        # Snap tiny negatives to zero
        if abs(new_counts[el]) < 1e-12:
            new_counts[el] = 0.0

    # Drop zeros
    for el, n in list(new_counts.items()):
        if n <= 0.0:
            del new_counts[el]

    return new_counts


def _validate_counts_for_isotopes(counts: Dict[str, float]) -> Dict[str, int]:
    """
    Validate counts for isotopic convolution:
      - Elements must exist in ms_isotopes_data
      - Stoichiometry must be non-negative integers (within small epsilon)
    Returns integer counts.
    Raises ValueError with clear messages when invalid.
    """
    if not counts:
        return {}

    int_counts: Dict[str, int] = {}
    for el, n in counts.items():
        if el not in ms_isotopes_data.ISOTOPES:
            raise ValueError(f"Unsupported element '{el}' in isotopic data.")
        if n < 0:
            raise ValueError(f"Negative stoichiometry for '{el}': {n}")
        # Allow tiny float noise; require near-integer
        n_round = int(round(n))
        if abs(n - n_round) > 1e-6:
            raise ValueError(
                f"Non-integer stoichiometry for '{el}': {n}. "
                f"Isotopic convolution requires integer counts."
            )
        if n_round > 0:
            int_counts[el] = n_round
    return int_counts


def _convolve_two(
    dist: List[Tuple[float, float]],
    iso: List[Tuple[float, float]],
) -> List[Tuple[float, float]]:
    """
    Convolve an existing distribution with one atom's isotopes.
    Inputs:
        dist: [(mass, abundance_fraction)], abundance_fraction in [0,1]
        iso : [(isotope_mass, abundance_fraction)], fractions sum ~1
    Output:
        new distribution [(mass, abundance_fraction)]
    """
    new: Dict[float, float] = {}
    for m0, a0 in dist:
        for mi, ai in iso:
            m = m0 + mi
            a = a0 * ai
            new[m] = new.get(m, 0.0) + a
    return list(new.items())


def _bin_and_prune(
    dist: List[Tuple[float, float]],
    bin_width: float,
    prune_threshold: float,
) -> List[Tuple[float, float]]:
    """
    Bin masses to 'bin_width' and prune entries below 'prune_threshold' (fraction),
    then normalize to 1.0 (fraction).
    """
    if not dist:
        return []

    # Bin by rounding to nearest bin center
    binned: Dict[float, float] = {}
    inv = 1.0 / bin_width
    for m, a in dist:
        key = round(m * inv) / inv
        binned[key] = binned.get(key, 0.0) + a

    # Prune very small fractions
    pruned = [(m, a) for m, a in binned.items() if a >= prune_threshold]
    if not pruned:
        return []

    # Normalize to 1.0 fraction
    total = sum(a for _, a in pruned)
    normed = [(m, a / total) for m, a in pruned]
    # Sort by mass
    normed.sort(key=lambda x: x[0])
    return normed


def convolve_isotopes(
    counts: Dict[str, float],
    bin_width: float = 1e-4,
    prune_threshold: float = 1e-6,
) -> List[Tuple[float, float]]:
    """
    Build isotopic distribution for a neutral formula using convolution.

    Parameters
    ----------
    counts : dict
        Elemental integer counts (floats permitted but must be near-integer).
    bin_width : float
        Binning width in Daltons for peak merging.
    prune_threshold : float
        Fraction threshold to drop very weak peaks (pre-normalization).

    Returns
    -------
    list of (mass, percent_abundance)
        Mass in Daltons, percent_abundance normalized to 100.

    Raises
    ------
    ValueError
        If an element is unsupported or counts are non-integer/negative.
    """
    int_counts = _validate_counts_for_isotopes(counts)
    if not int_counts:
        return []

    # Start with a single "zero-mass" unit with full abundance fraction
    dist: List[Tuple[float, float]] = [(0.0, 1.0)]

    # Convolve element by element, atom by atom
    for el, n in int_counts.items():
        iso = ms_isotopes_data.ISOTOPES[el]  # [(mass, fraction)]
        for _ in range(n):
            dist = _convolve_two(dist, iso)
            dist = _bin_and_prune(dist, bin_width, prune_threshold)
            if not dist:
                # If pruning eliminated all peaks, bail out with empty list
                return []

    # Final normalization to percent scale
    total_fraction = sum(a for _, a in dist)
    if total_fraction <= 0.0:
        return []

    out = [(m, a / total_fraction * 100.0) for m, a in dist]
    out.sort(key=lambda x: x[0])
    return out


def peaks_with_charge(
    dist: List[Tuple[float, float]],
    charge: int,
    mass_offset: float = 0.0,
) -> List[Tuple[float, float]]:
    """
    Convert neutral isotopic masses to m/z given charge and optional mass_offset.

    Parameters
    ----------
    dist : list of (mass, percent_abundance)
        Output of convolve_isotopes (percent normalized to 100).
    charge : int
        Absolute charge magnitude (must be non-zero).
    mass_offset : float
        Additional mass correction (e.g., +/- electron mass). Default 0.0.

    Returns
    -------
    list of (m/z, percent_abundance)

    Raises
    ------
    ValueError
        If charge is zero.
    """
    if charge == 0:
        raise ValueError("Charge must be non-zero.")
    if not dist:
        return []

    c = float(abs(charge))
    out = [((m + mass_offset) / c, a) for (m, a) in dist]
    out.sort(key=lambda x: x[0])
    return out