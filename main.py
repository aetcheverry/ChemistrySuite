# -*- coding: utf-8 -*-
"""main

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18ovt9BMqgWuONItnnJJUuMPiT_kpj06I
"""

import os
import sys
import traceback
from typing import Callable, Dict, Optional, Tuple
from pathlib import Path

from PyQt6.QtCore import Qt, QTimer, QUrl, QSettings, QCoreApplication, QEvent, pyqtSignal
from PyQt6.QtGui import QAction, QIcon, QGuiApplication, QFont, QFontDatabase, QFontInfo, QPalette
from PyQt6.QtWidgets import (
    QApplication,
    QMainWindow,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QTreeWidget,
    QTreeWidgetItem,
    QTreeWidgetItemIterator,
    QStackedWidget,
    QLabel,
    QSplitter,
    QStatusBar,
    QMessageBox,
    QDialog,
    QDialogButtonBox,
    QTextBrowser,
    QProgressBar,
    QFormLayout,
    QRadioButton,
    QGroupBox,
    QCheckBox,
    QComboBox,
    QSpinBox,
    QLineEdit,
    QPushButton,
    QFileDialog,
    QListWidget,
    QListWidgetItem,
    QStyleFactory,
)

# --- Attempt QtWebEngine import at module load (required by Qt) ---
WEBENGINE_AVAILABLE = False
try:
    # Import before any Q(Core\Gui)Application to avoid runtime error.
    from PyQt6.QtWebEngineCore import QWebEnginePage # type: ignore
    from PyQt6.QtWebEngineWidgets import QWebEngineView  # type: ignore

    WEBENGINE_AVAILABLE = True
except Exception:
    WEBENGINE_AVAILABLE = False

# --- Global Path Setup (centralized) ---
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
if BASE_DIR not in sys.path:
    sys.path.insert(0, BASE_DIR)
RESOURCES_DIR = os.path.join(BASE_DIR, "resources")
WIDGETS_DIR = os.path.join(BASE_DIR, "widgets")
INSTRUCTIONS_DIR = os.path.join(BASE_DIR, "instructions")
HOME_PAGE_PATH = os.path.join(RESOURCES_DIR, "home_page.html")

# Shared helpers (ensure_instruction_page, BaseWidget)
from logic.shared_functions import (
    ensure_instruction_page,
    BaseWidget,
    HELP_PAGE_ALIASES,
    _read_text,
    _is_placeholder_html,
)

# --- Diagnostic helpers ---
TRACE_IMPORTS = os.environ.get("TRACE", "").strip() in {"1", "true", "True"}

def warn(msg: str) -> None:
    print(f"[ChemistrySuite][WARN] {msg}")

def trace(msg: str) -> None:
    if TRACE_IMPORTS:
        print(f"[ChemistrySuite][TRACE] {msg}")
        traceback.print_exc()
    else:
        warn(msg)

# --- Navigation Map (HTML href -> Sidebar Title) ---
SLUG_MAP = {
    "solvent_data": "Solvent Properties",
    "nmr_impurities": "NMR Impurities",
    "calc_molarity": "Dilution Calculator",
    "calc_dosy": "DOSY NMR Calculator",
    "calc_ea": "Elemental Analysis",
    "calc_iso": "Isotopic Distribution",
    "solvent_miscibility": "Solvent Miscibility"
}

# --- Proactively normalise/upgrade instruction pages from known aliases ---

def _migrate_instruction_pages(instructions_dir: str) -> None:
    """
    If the expected help filename is missing or is a placeholder, but a rich alias
    (e.g., solvent_misc_inst.html, dil_calculator_inst.html) exists, copy the alias
    content into the expected filename so F1 resolves consistently.

    Non-destructive: it *never* overwrites finalized pages.
    """
    try:
        root = Path(instructions_dir)
        root.mkdir(parents=True, exist_ok=True)
        for expected, alias in HELP_PAGE_ALIASES.items():
            exp_path = root / expected
            alias_path = root / alias

            # Alias must exist and look finalized (i.e., not a placeholder)
            if not alias_path.exists():
                continue
            alias_text = _read_text(alias_path) or ""
            if _is_placeholder_html(alias_text):
                continue

            # Upgrade only if expected is missing or currently a placeholder
            if not exp_path.exists():
                try:
                    exp_path.write_text(alias_text, encoding="utf-8")
                except Exception:
                    # Non-fatal; continue
                    pass
                continue


            # Expected exists: only upgrade if it's a placeholder
            exp_text = _read_text(exp_path) or ""
            if _is_placeholder_html(exp_text):
                try:
                    exp_path.write_text(alias_text, encoding="utf-8")
                except Exception:
                    # Non-fatal; continue
                    pass
    except Exception:
        # Migration is non-critical; never raise
        pass


# ---------------------------------------------------------------------------
# Preferences management
# ---------------------------------------------------------------------------
class PrefKeys:
    ORG = "ChemistrySuite"
    APP = "ChemistrySuiteApp"
    THEME = "appearance/theme"  # "system" | "light" | "dark"
    PREFER_WEBENGINE = "behavior/prefer_webengine"  # bool
    SHOW_LOADING = "behavior/show_loading"  # bool
    CONFIRM_EXIT = "behavior/confirm_exit"  # bool
    EXPORT_FORMAT = "plotting/export_format"  # "PNG" | "SVG" | "PDF" | "JPG"
    EXPORT_DPI = "plotting/export_dpi"  # int
    EXPORT_TRANSPARENT = "plotting/transparent_bg"  # bool
    EXPORT_DIR = "paths/export_dir"  # str path
    FONT_SIZE = "appearance/font_size"  # "Small" / "Normal" / "Large"
    FONT_BASELINE_PT = "appearance/font_baseline_pt" #int: point size of baseline OS/theme font

class PreferencesManager:
    """Simple wrapper for QSettings with apply helpers."""

    def __init__(self):
        self.settings = QSettings(PrefKeys.ORG, PrefKeys.APP)

    # Defaults
    DEFAULTS = {
        PrefKeys.THEME: "system",
        PrefKeys.PREFER_WEBENGINE: True,
        PrefKeys.SHOW_LOADING: True,
        PrefKeys.CONFIRM_EXIT: False,
        PrefKeys.EXPORT_FORMAT: "PNG",
        PrefKeys.EXPORT_DPI: 150,
        PrefKeys.EXPORT_TRANSPARENT: False,
        PrefKeys.EXPORT_DIR: "",
        PrefKeys.FONT_SIZE: "Small",
        PrefKeys.FONT_BASELINE_PT: 0, # 0 -> compute on first apply/startup
    }

    def get(self, key):
        if key in (PrefKeys.PREFER_WEBENGINE, PrefKeys.SHOW_LOADING, PrefKeys.CONFIRM_EXIT, PrefKeys.EXPORT_TRANSPARENT):
            return self.settings.value(key, self.DEFAULTS[key], type=bool)
        if key == PrefKeys.EXPORT_DPI:
            return self.settings.value(key, self.DEFAULTS[key], type=int)
        return self.settings.value(key, self.DEFAULTS[key], type=str)

    def set(self, key, value):
        self.settings.setValue(key, value)



    def apply_theme(self, app: QApplication, theme: Optional[str] = None):
        """Apply theme by switching style + palette in a consistent way."""
        def _set_style(name: str):
            style = QStyleFactory.create(name)
            if style is not None:
                app.setStyle(style)

        theme = (theme or self.get(PrefKeys.THEME)).lower()

        if theme == "dark":
            # Fusion + explicit dark palette
            _set_style("Fusion")
            app.setPalette(build_dark_palette())

        elif theme == "light":
            # Fusion + explicit light palette (do NOT leave the old dark palette)
            _set_style("Fusion")
            app.setPalette(build_light_palette())

        else:  # "system"
            # Respect OS color scheme when available (Qt 6.5+)
            scheme = Qt.ColorScheme.Light
            try:
                scheme = QGuiApplication.styleHints().colorScheme()
            except Exception:
                pass

            if scheme == Qt.ColorScheme.Dark:
                _set_style("Fusion")
                app.setPalette(build_dark_palette())
            else:
            # Use platform style if present; otherwise Fusion, then apply light palette
                keys = {k.lower(): k for k in QStyleFactory.keys()}
                target = keys.get("windowsvista") or keys.get("windows") or "Fusion"
                _set_style(target)

    def snapshot_baseline_font(self, app: QApplication) -> None:
        """
        Capture the application's baseline font (after theme is applied).
        This avoids cumulative growth when Apply/OK is clicked multiple times.
        """
        try:
            # Create (or refresh) a copy of the current app font as the baseline
            app._baseline_font = QFont(app.font())
        except Exception:
            # Fallback: do notthing; apply_font_size will use app.font() directly
            pass
    def compute_and_store_font_baseline(self, app: QApplication) -> int:
        """
        Capture the baseline font point size from the current OS/theme and store it.
        Called after apply_theme() so it reflects the selected theme.
        """
        try:
            sys_font = QFontDatabase.systemFont(QFontDatabase.SystemFont.GeneralFont)
            pt = sys_font.pointSize()
        except Exception:
            pt = -1

        if pt is None or pt <= 0:
            # Fallback: inspect the *current* app font via QFontInfo
            pt = QFontInfo(app.font()).pointSize()
        if pt is None or pt <= 0:
            pt = 10 # Safe fallback

            # Persist the baseline so subsequent applies are idempotent
        self.set(PrefKeys.FONT_BASELINE_PT, int(pt))
        return int(pt)


    def apply_font_size(self, app: QApplication) -> None:
        """
        Apply user-selected global font size. Keeps 'Small' as baseline (current OS font),
        'Normal' = +2 pt, 'Large' = +4 pt over the baseline.
        """
        choice = str(self.get(PrefKeys.FONT_SIZE) or "Small").title()

        # Get baseline (compute if not present)
        try:
            baseline_pt = int(self.get(PrefKeys.FONT_BASELINE_PT) or 0)
        except Exception:
            baseline_pt = 0
        if baseline_pt <= 0:
            baseline_pt = self.compute_and_store_font_baseline(app)

        delta = 0
        if choice == "Normal":
            delta = 2
        elif choice == "Large":
            delta = 4

        # Always start from a clean system font, not app.font() (avoids accumulation)
        base = QFontDatabase.systemFont(QFontDatabase.SystemFont.GeneralFont)
        base.setPointSize(max(6, baseline_pt + delta))
        app.setFont(base) # Apply the new font to the application



    def apply_runtime_flags(self, app: QApplication):
        """Expose flags on the QApplication instance for easy access in dialogs."""
        setattr(app, "_prefer_webengine", bool(self.get(PrefKeys.PREFER_WEBENGINE)))
        setattr(app, "_confirm_exit", bool(self.get(PrefKeys.CONFIRM_EXIT)))
        setattr(app, "_default_export_format", str(self.get(PrefKeys.EXPORT_FORMAT)))
        setattr(app, "_default_export_dpi", int(self.get(PrefKeys.EXPORT_DPI)))
        setattr(app, "_default_export_transparent", bool(self.get(PrefKeys.EXPORT_TRANSPARENT)))
        setattr(app, "_default_export_dir", str(self.get(PrefKeys.EXPORT_DIR)))


def build_dark_palette():
    """Return a Fusion-friendly dark QPalette."""
    from PyQt6.QtGui import QPalette, QColor

    palette = QPalette()
    # Base colors
    palette.setColor(QPalette.ColorRole.Window, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.WindowText, QColor(220, 220, 220))
    palette.setColor(QPalette.ColorRole.Base, QColor(42, 42, 42))
    palette.setColor(QPalette.ColorRole.AlternateBase, QColor(66, 66, 66))
    palette.setColor(QPalette.ColorRole.ToolTipBase, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ToolTipText, QColor(220, 220, 220))
    palette.setColor(QPalette.ColorRole.Text, QColor(220, 220, 220))
    palette.setColor(QPalette.ColorRole.Button, QColor(53, 53, 53))
    palette.setColor(QPalette.ColorRole.ButtonText, QColor(220, 220, 220))
    palette.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    palette.setColor(QPalette.ColorRole.Highlight, QColor(42, 130, 218))
    palette.setColor(QPalette.ColorRole.HighlightedText, QColor(0, 0, 0))
    return palette


def build_light_palette():
    """Return a light QPalette (close to Fusion defaults)."""
    from PyQt6.QtGui import QPalette, QColor
    p = QPalette()
    p.setColor(QPalette.ColorRole.Window, QColor(240, 240, 240))
    p.setColor(QPalette.ColorRole.WindowText, QColor(0, 0, 0))
    p.setColor(QPalette.ColorRole.Base, QColor(255, 255, 255))
    p.setColor(QPalette.ColorRole.AlternateBase, QColor(245, 245, 245))
    p.setColor(QPalette.ColorRole.ToolTipBase, QColor(255, 255, 220))
    p.setColor(QPalette.ColorRole.ToolTipText, QColor(0, 0, 0))
    p.setColor(QPalette.ColorRole.Text, QColor(0, 0, 0))
    p.setColor(QPalette.ColorRole.Button, QColor(240, 240, 240))
    p.setColor(QPalette.ColorRole.ButtonText, QColor(0, 0, 0))
    p.setColor(QPalette.ColorRole.BrightText, QColor(255, 0, 0))
    p.setColor(QPalette.ColorRole.Highlight, QColor(0, 120, 215))        # Windows-like accent
    p.setColor(QPalette.ColorRole.HighlightedText, QColor(255, 255, 255))


    return p


# ---------------------------------------------------------------------------
# Preferences Dialog
# ---------------------------------------------------------------------------
class PreferencesDialog(QDialog):
    """Side-panel preferences dialog."""

    def __init__(self, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.setWindowTitle("Preferences")
        self.resize(720, 480)
        self.pref = PreferencesManager()
        self._pending = {}  # staged changes before apply

        # Layout
        root = QHBoxLayout(self)

        # Left list (categories)
        self.cat_list = QListWidget(self)
        for name in ["Appearance", "Behavior", "Plotting", "Paths"]:
            QListWidgetItem(name, self.cat_list)
        self.cat_list.setFixedWidth(160)
        root.addWidget(self.cat_list)

        # Right stack (pages)
        self.pages = QStackedWidget(self)
        root.addWidget(self.pages, 1)

        # Build pages
        self.appearance_page = self._build_appearance_page()
        self.behavior_page = self._build_behavior_page()
        self.plotting_page = self._build_plotting_page()
        self.paths_page = self._build_paths_page()

        self.pages.addWidget(self.appearance_page)
        self.pages.addWidget(self.behavior_page)
        self.pages.addWidget(self.plotting_page)
        self.pages.addWidget(self.paths_page)

        # Buttons
        btn_box = QDialogButtonBox(
            QDialogButtonBox.StandardButton.Ok
            | QDialogButtonBox.StandardButton.Apply
            | QDialogButtonBox.StandardButton.Cancel,
            self,
        )
        btn_box.accepted.connect(self._on_ok)     # OK
        btn_box.button(QDialogButtonBox.StandardButton.Apply).clicked.connect(self._on_apply)
        btn_box.rejected.connect(self.reject)     # Cancel
        root.addWidget(btn_box)

        # Signals
        self.cat_list.currentRowChanged.connect(self.pages.setCurrentIndex)
        self.cat_list.setCurrentRow(0)

    # --- Pages builders ---
    def _build_appearance_page(self) -> QWidget:
        w = QWidget(self)
        form = QFormLayout(w)

        # Theme radio buttons
        grp = QGroupBox("Theme", w)
        g_layout = QVBoxLayout(grp)
        self.rb_system = QRadioButton("System (default)", grp)
        self.rb_light = QRadioButton("Light", grp)
        self.rb_dark = QRadioButton("Dark", grp)
        g_layout.addWidget(self.rb_system)
        g_layout.addWidget(self.rb_light)
        g_layout.addWidget(self.rb_dark)
        form.addRow(grp)

        # Font size
        grp_fs = QGroupBox("Font Size", w)
        fs_layout = QVBoxLayout(grp_fs)

        self.fs_small = QRadioButton("Small", grp_fs)
        self.fs_normal = QRadioButton("Normal", grp_fs)
        self.fs_large = QRadioButton("Large", grp_fs)

        fs_layout.addWidget(self.fs_small)
        fs_layout.addWidget(self.fs_normal)
        fs_layout.addWidget(self.fs_large)

        form.addRow(grp_fs)

        # Load current font size selection
        fs_choice = str(self.pref.get(PrefKeys.FONT_SIZE)).strip().title()
        if fs_choice not in {"Small", "Normal", "Large"}:
            fs_choice = "Small"
        (getattr(self, f"fs_{fs_choice.lower()}")).setChecked(True)

        # Stage changes on toggle
        self.fs_small.toggled.connect(lambda on: on and self._stage(PrefKeys.FONT_SIZE, "Small"))
        self.fs_normal.toggled.connect(lambda on: on and self._stage(PrefKeys.FONT_SIZE, "Normal"))
        self.fs_large.toggled.connect(lambda on: on and self._stage(PrefKeys.FONT_SIZE, "Large"))

        # Load current theme
        theme = str(self.pref.get(PrefKeys.THEME)).lower()
        if theme == "dark":
            self.rb_dark.setChecked(True)
        elif theme == "light":
            self.rb_light.setChecked(True)
        else:
            self.rb_system.setChecked(True)

        # Staging on change
        self.rb_system.toggled.connect(lambda on: on and self._stage(PrefKeys.THEME, "system"))
        self.rb_light.toggled.connect(lambda on: on and self._stage(PrefKeys.THEME, "light"))
        self.rb_dark.toggled.connect(lambda on: on and self._stage(PrefKeys.THEME, "dark"))

        return w

    def _build_behavior_page(self) -> QWidget:
        w = QWidget(self)
        form = QFormLayout(w)

        self.cb_webengine = QCheckBox("Prefer WebEngine for Help (if available)", w)
        self.cb_webengine.setChecked(bool(self.pref.get(PrefKeys.PREFER_WEBENGINE)))
        self.cb_webengine.toggled.connect(lambda v: self._stage(PrefKeys.PREFER_WEBENGINE, bool(v)))
        form.addRow(self.cb_webengine)

        self.cb_loading = QCheckBox("Show loading screen on startup", w)
        self.cb_loading.setChecked(bool(self.pref.get(PrefKeys.SHOW_LOADING)))
        self.cb_loading.toggled.connect(lambda v: self._stage(PrefKeys.SHOW_LOADING, bool(v)))
        form.addRow(self.cb_loading)

        self.cb_confirm_exit = QCheckBox("Confirm on exit", w)
        self.cb_confirm_exit.setChecked(bool(self.pref.get(PrefKeys.CONFIRM_EXIT)))
        self.cb_confirm_exit.toggled.connect(lambda v: self._stage(PrefKeys.CONFIRM_EXIT, bool(v)))
        form.addRow(self.cb_confirm_exit)

        return w

    def _build_plotting_page(self) -> QWidget:
        w = QWidget(self)
        form = QFormLayout(w)

        self.combo_format = QComboBox(w)
        self.combo_format.addItems(["PNG", "SVG", "PDF", "JPG"])
        self.combo_format.setCurrentText(str(self.pref.get(PrefKeys.EXPORT_FORMAT)))
        self.combo_format.currentTextChanged.connect(lambda s: self._stage(PrefKeys.EXPORT_FORMAT, s))
        form.addRow("Default export format:", self.combo_format)

        self.spin_dpi = QSpinBox(w)
        self.spin_dpi.setRange(50, 1200)
        self.spin_dpi.setValue(int(self.pref.get(PrefKeys.EXPORT_DPI)))
        self.spin_dpi.valueChanged.connect(lambda v: self._stage(PrefKeys.EXPORT_DPI, int(v)))
        form.addRow("Default DPI:", self.spin_dpi)

        self.cb_transparent = QCheckBox("Transparent background", w)
        self.cb_transparent.setChecked(bool(self.pref.get(PrefKeys.EXPORT_TRANSPARENT)))
        self.cb_transparent.toggled.connect(lambda v: self._stage(PrefKeys.EXPORT_TRANSPARENT, bool(v)))
        form.addRow(self.cb_transparent)

        return w

    def _build_paths_page(self) -> QWidget:
        w = QWidget(self)
        form = QFormLayout(w)

        self.edit_export_dir = QLineEdit(w)
        self.edit_export_dir.setText(str(self.pref.get(PrefKeys.EXPORT_DIR)))
        btn_browse = QPushButton("Browse…", w)

        def browse():
            path = QFileDialog.getExistingDirectory(self, "Choose export folder", self.edit_export_dir.text() or "")
            if path:
                self.edit_export_dir.setText(path)
                self._stage(PrefKeys.EXPORT_DIR, path)

        btn_browse.clicked.connect(browse)
        row = QWidget(w)
        h = QHBoxLayout(row)
        h.setContentsMargins(0, 0, 0, 0)
        h.addWidget(self.edit_export_dir, 1)
        h.addWidget(btn_browse)
        form.addRow("Default export folder:", row)

        return w

    # --- Staging & applying ---
    def _stage(self, key, value):
        self._pending[key] = value

    def _apply(self):
        # Write staged changes
        for k, v in self._pending.items():
            self.pref.set(k, v)
        self._pending.clear()

        # Apply runtime preferences to the app immediately
        app = QApplication.instance()
        if app:
            # Theme
            self.pref.apply_theme(app, self.pref.get(PrefKeys.THEME))

            pal = app.palette()
            p = QPalette()
            p.setColor(QPalette.ColorRole.ToolTipBase, pal.color(QPalette.ColorRole.ToolTipBase))
            p.setColor(QPalette.ColorRole.ToolTipText, pal.color(QPalette.ColorRole.ToolTipText))
            for w in app.allWidgets():
                QCoreApplication.postEvent(w, QEvent(QEvent.Type.PaletteChange))
            app.processEvents()
            # Runtime flags on app instance
            self.pref.apply_runtime_flags(app)
            # Font size
            self.pref.snapshot_baseline_font(app)
            self.pref.compute_and_store_font_baseline(app)
            self.pref.apply_font_size(app)
            for w in app.allWidgets():
                QCoreApplication.postEvent(w, QEvent(QEvent.Type.ApplicationFontChange))
                QCoreApplication.postEvent(w, QEvent(QEvent.Type.FontChange))
            app.processEvents()
            try:
                for tlw in app.topLevelWidgets():
                    tlw.setFont(app.font())
                    tlw.update()
            except Exception:
                pass

    def _on_apply(self):
        self._apply()

    def _on_ok(self):
        self._apply()
        self.accept()


# --- Generic placeholder widget ---
class GenericPlaceholder(QWidget):
    """A simple center-aligned label placeholder (optionally shows details)."""

    def __init__(self, name: str, detail: Optional[str] = None, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout()
        layout.setContentsMargins(24, 24, 24, 24)
        title = QLabel(f"Module: {name}")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        title_font = title.font()
        title_font.setPointSize(14)
        title_font.setBold(True)
        title.setFont(title_font)
        layout.addStretch()
        layout.addWidget(title)
        if detail:
            info = QLabel(detail)
            info.setAlignment(Qt.AlignmentFlag.AlignCenter)
            info.setWordWrap(True)
            layout.addSpacing(10)
            layout.addWidget(info)
        layout.addStretch()
        self.setLayout(layout)


# --- Custom WebEngine Page for Navigation Interception ---
if WEBENGINE_AVAILABLE:
    class InterceptingWebPage(QWebEnginePage):
        def __init__(self, parent_view, signal_callback):
            super().__init__(parent_view)
            self._callback = signal_callback

        def acceptNavigationRequest(self, url: QUrl, _type: 'QWebEnginePage.NavigationType', isMainFrame: bool) -> bool:
            # Check if this is a link click
            if _type == QWebEnginePage.NavigationType.NavigationTypeLinkClicked:
                # Extract the "slug" from the URL path
                # e.g. "file:///.../calc_ea" -> "calc_ea"
                slug = url.toString().split('/')[-1]
                # If we have a hash, clean it (e.g., "#calc_ea" -> "calc_ea")
                if '#' in slug:
                    slug = slug.split('#')[-1]

                # Call the signal/callback with the slug and BLOCK the navigation
                self._callback(slug)
                return False
            return super().acceptNavigationRequest(url, _type, isMainFrame)


# --- Home page widget (WebEngine if available, else QTextBrowser) ---
class HomePageWidget(QWidget):
    help_key = "main"  # so F1 resolves to instructions/main_inst.html

    # Signal to request navigation to a specific module slug
    navigate_signal = pyqtSignal(str)

    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent)
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        prefer_webengine = getattr(QApplication.instance(), "_prefer_webengine", True)
        use_webengine = WEBENGINE_AVAILABLE and prefer_webengine

        if use_webengine and os.path.exists(HOME_PAGE_PATH):
            try:
                view = QWebEngineView(self)
                # Use our custom page to intercept clicks
                page = InterceptingWebPage(view, self.navigate_signal.emit)
                view.setPage(page)

                url = QUrl.fromLocalFile(HOME_PAGE_PATH)
                view.load(url)
                layout.addWidget(view)
                return
            except Exception as e:
                trace(f"Failed to initialize QWebEngineView; falling back: {e}")

        # Fallback to QTextBrowser
        browser = QTextBrowser(self)
        browser.setOpenLinks(False)  # We will handle links manually
        browser.anchorClicked.connect(self._on_anchor_clicked)

        if os.path.exists(HOME_PAGE_PATH):
            try:
                with open(HOME_PAGE_PATH, "r", encoding="utf-8") as f:
                    html = f.read()
                browser.setHtml(html)
            except Exception as e:
                browser.setHtml(f"<h3>Error loading home_page.html</h3><p>{e}</p>")
        else:
            browser.setHtml(
                "<h2>Chemistry Suite</h2>"
                "<p><i>home_page.html</i> not found in the resources folder.</p>"
            )
        layout.addWidget(browser)

    def _on_anchor_clicked(self, url: QUrl):
        # Handle QTextBrowser links
        slug = url.toString()
        if '#' in slug:
            slug = slug.split('#')[-1]
        self.navigate_signal.emit(slug)


# --- Default placeholders (replaced by real classes on successful import) ---
SolventPropertiesWidget = lambda: GenericPlaceholder("Solvent Properties")
EACalculatorWidget = lambda: GenericPlaceholder("Elemental Analysis Calculator")
DilutionCalculatorWidget = lambda: GenericPlaceholder("Dilution Calculator")
DOSYCalculatorWidget = lambda: GenericPlaceholder("DOSY NMR Calculator")
IsotopicDistCalculatorWidget = lambda: GenericPlaceholder("Isotopic Distribution")
NMRImpuritiesWidget = lambda: GenericPlaceholder("NMR Impurities")
SolventMiscibilityWidget = lambda: GenericPlaceholder("Solvent Miscibility")

# --- Attempt to import real widgets (safe fallbacks retained on failure) ---
try:
    from widgets.ea_calculator import EACalculator as EACalculatorWidget
except Exception as e:
    trace(f"EA Calculator not available: {e}")
try:
    from widgets.iso_dist_calculator import IsotopicDistCalculator as IsotopicDistCalculatorWidget
except Exception as e:
    trace(f"Isotopic Distribution Calculator not available: {e}")
try:
    from widgets.dil_calculator import DilutionCalculator as DilutionCalculatorWidget
except Exception as e:
    trace(f"Dilution Calculator not available: {e}")
try:
    from widgets.dosy_calculator import DOSYCalculator as DOSYCalculatorWidget
except Exception as e:
    trace(f"DOSY NMR Calculator not available: {e}")
try:
    from widgets.solvent_properties import SolventPropertiesWidget  # type: ignore
except Exception as e:
    trace(f"Solvent Properties widget not available: {e}")
try:
    from widgets.nmr_impurities import NMRImpuritiesWidget as NMRImpuritiesWidget
except Exception as e:
    trace(f"NMR Impurities widget not available: {e}")
try:
    from widgets.solvent_misc import SolventMiscibilityWidget
except Exception as e:
    trace(f"Solvent Miscibility widget not available: {e}")


# --- Help Viewer Dialog (WebEngine preferred, QTextBrowser fallback) ---
class HelpViewerDialog(QDialog):
    """
    Shows HTML help pages. Prefers QWebEngineView (richer HTML/CSS/JS) if available
    AND the user preference is set; otherwise falls back to QTextBrowser.
    Parameters:
        html_content: fallback HTML string (used when WebEngine isn't available or file not found)
        file_path: optional absolute path to the .html help file; if provided and WebEngine
                   is available, it will be loaded via QUrl.fromLocalFile(...)
    """

    def __init__(self, html_content: str, file_path: Optional[str] = None, parent: Optional[QWidget] = None) -> None:  # type: ignore
        super().__init__(parent)
        self.setWindowTitle("Instructions")
        self.resize(900, 650)
        self._backend = "textbrowser"  # "webengine" or "textbrowser"
        self._file_path = file_path
        layout = QVBoxLayout()
        self.setLayout(layout)

        # Try WebEngine first if preference allows
        prefer_webengine = getattr(QApplication.instance(), "_prefer_webengine", True)
        self._view = None
        self._browser = None

        if WEBENGINE_AVAILABLE and prefer_webengine:
            try:
                self._view = QWebEngineView(self)
                if file_path and os.path.exists(file_path):
                    self._view.load(QUrl.fromLocalFile(file_path))
                else:
                    # Use setHtml if we don't have a file (baseUrl helps resolve relative links if needed)
                    self._view.setHtml(html_content or "<h3>No content</h3><p>Help page is empty.</p>", QUrl("about:blank"))
                layout.addWidget(self._view)
                self._backend = "webengine"
            except Exception as e:
                print(f"[HelpViewer][WARN] WebEngine init failed, falling back: {e}")
                self._view = None

        if self._view is None:
            self._browser = QTextBrowser(self)
            self._browser.setOpenExternalLinks(True)
            self._browser.setHtml(html_content or "<h3>No content</h3><p>Help page is empty.</p>")
            layout.addWidget(self._browser)
            self._backend = "textbrowser"

        # Close button
        btn_box = QDialogButtonBox(QDialogButtonBox.StandardButton.Close)
        btn_box.rejected.connect(self.close)
        layout.addWidget(btn_box)

    def set_content(self, html_content: str, file_path: Optional[str] = None) -> None:
        self._file_path = file_path

        # Helper to switch to browser mode safely
        def switch_to_browser():
            if self._view is not None:
                self._view.setVisible(False)  # Hide the broken view
            if self._browser is None:
                self._browser = QTextBrowser(self)
                self._browser.setOpenExternalLinks(True)
                self.layout().insertWidget(0, self._browser)
            self._browser.setHtml(html_content or "<h3>No content</h3><p>Help page is empty.</p>")
            self._backend = "textbrowser"

        prefer_webengine = getattr(QApplication.instance(), "_prefer_webengine", True)

        if self._backend == "webengine" and self._view is not None and (WEBENGINE_AVAILABLE and prefer_webengine):
            try:
                if file_path and os.path.exists(file_path):
                    self._view.load(QUrl.fromLocalFile(file_path))
                else:
                    self._view.setHtml(html_content or "<h3>No content</h3><p>Help page is empty.</p>", QUrl("about:blank"))
                self._view.setVisible(True)  # Ensure it's visible if we are using it
            except Exception as e:
                print(f"[HelpViewer][WARN] WebEngine set_content failed: {e}")
                switch_to_browser()
        else:
            switch_to_browser()


# --- Application Window ---
class ChemistrySuiteApp(QMainWindow):
    def __init__(self) -> None:
        super().__init__()
        self.setWindowTitle("Chemistry Suite")
        self.resize(1200, 800)
        icon_path = os.path.join(RESOURCES_DIR, "icon.ico")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        # Preferences manager
        self.pref = PreferencesManager()
        self.pref.apply_runtime_flags(QApplication.instance())
        self.pref.apply_theme(QApplication.instance())
        self.pref.snapshot_baseline_font(QApplication.instance())
        self.pref.compute_and_store_font_baseline(QApplication.instance()) # Fixed typo
        self.pref.apply_font_size(QApplication.instance())

        self.help_window: Optional[HelpViewerDialog] = None

        # UI shell
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)

        splitter = QSplitter(Qt.Orientation.Horizontal)
        self.sidebar = QTreeWidget()
        self.sidebar.setHeaderHidden(True)
        self.sidebar.setMaximumWidth(280)
        self.sidebar.setMinimumWidth(180)
        splitter.addWidget(self.sidebar)

        self.content_stack = QStackedWidget()
        splitter.addWidget(self.content_stack)
        main_layout.addWidget(splitter)

        # Status bar and menus before selecting any item
        self._setup_statusbar()
        self._setup_menubar()

        # Lazy-load registry (key -> (factory, title))
        self._registry: Dict[str, Tuple[Callable[[], QWidget], str]] = {}
        self._key_counter: int = 0  # unique keys, even with repeated labels

        # Sidebar population
        self._setup_sidebar_items()

        # React to page changes (keep Edit menu state in sync)
        self.content_stack.currentChanged.connect(lambda _idx: self._refresh_edit_menu())
        self.sidebar.itemClicked.connect(self._on_sidebar_click)

        # Run the migration before ensuring main help page
        _migrate_instruction_pages(INSTRUCTIONS_DIR)

        # Ensure main help page exists
        ensure_instruction_page(INSTRUCTIONS_DIR, "main_inst.html", "Chemistry Suite")

        # Select Home AFTER status bar exists
        self.sidebar.setCurrentItem(self.item_home)
        self._on_sidebar_click(self.item_home, 0)

    # --- Sidebar population (lazy loading) ---
    def _new_key(self, label: str) -> str:
        self._key_counter += 1
        base = label.lower().replace(" ", "_")
        return f"{base}__{self._key_counter}"

    def _add_sidebar_leaf(
        self,
        parent: Optional[QTreeWidgetItem],
        label: str,
        factory: Callable[[], QWidget],
        title: str,
    ) -> QTreeWidgetItem:
        """Create a leaf item, register its factory/title, and stash the key on the item."""
        item = QTreeWidgetItem(parent if parent is not None else self.sidebar)
        item.setText(0, label)
        key = self._new_key(label)
        self._registry[key] = (factory, title)
        item.setData(0, Qt.ItemDataRole.UserRole, key)
        item.setData(0, Qt.ItemDataRole.UserRole + 1, -1)  # stack index placeholder
        return item

    def _setup_sidebar_items(self) -> None:
        font_bold = self.sidebar.font()
        font_bold.setBold(True)

        # --- Home (top-level) ---
        self.item_home = self._add_sidebar_leaf(
            parent=None,
            label="Home",
            factory=HomePageWidget,
            title="Chemistry Suite",
        )

        # --- Calculators category ---
        cat_calc = QTreeWidgetItem(self.sidebar)
        cat_calc.setText(0, "Calculators")
        cat_calc.setExpanded(True)
        cat_calc.setFont(0, font_bold)
        self.item_dil = self._add_sidebar_leaf(
            cat_calc, "Dilution Calculator", DilutionCalculatorWidget, "Dilution Calculator"
        )
        self.item_dosy = self._add_sidebar_leaf(
            cat_calc, "DOSY NMR Calculator", DOSYCalculatorWidget, "DOSY NMR Calculator"
        )
        self.item_ea = self._add_sidebar_leaf(
            cat_calc, "Elemental Analysis", EACalculatorWidget, "Elemental Analysis"
        )
        self.item_iso = self._add_sidebar_leaf(
            cat_calc, "Isotopic Distribution", IsotopicDistCalculatorWidget, "Isotopic Distribution"
        )

        # --- Reference category ---
        cat_ref = QTreeWidgetItem(self.sidebar)
        cat_ref.setText(0, "Reference")
        cat_ref.setExpanded(True)
        cat_ref.setFont(0, font_bold)
        self.item_nmr = self._add_sidebar_leaf(
            cat_ref, "NMR Impurities", NMRImpuritiesWidget, "NMR Impurities"
        )
        self.item_solvents = self._add_sidebar_leaf(
            cat_ref, "Solvent Properties", SolventPropertiesWidget, "Solvent Properties"
        )
        self.item_misc = self._add_sidebar_leaf(
            cat_ref, "Solvent Miscibility", SolventMiscibilityWidget, "Solvent Miscibility"
        )

    # --- Menu bar (File, Edit, Help) ---
    def _setup_menubar(self) -> None:
        menu_bar = self.menuBar()

        # File
        file_menu = menu_bar.addMenu("&File")

        # Preferences...
        pref_action = QAction("Preferences…", self)
        pref_action.setShortcut("Ctrl+P")
        pref_action.triggered.connect(self._show_preferences)
        file_menu.addAction(pref_action)

        file_menu.addSeparator()

        home_action = QAction("Home", self)
        home_action.setShortcut("Ctrl+H")
        home_action.triggered.connect(self._go_home)
        file_menu.addAction(home_action)

        file_menu.addSeparator()

        exit_action = QAction("Exit Chemistry Suite", self)
        exit_action.setShortcut("Alt+F4")
        exit_action.triggered.connect(self._on_exit)
        file_menu.addAction(exit_action)

        # Edit (context-aware)
        self.edit_menu = menu_bar.addMenu("&Edit")
        self.act_clear = QAction("Clear Inputs", self)
        self.act_clear.setShortcut("Ctrl+X")
        self.act_clear.triggered.connect(self._edit_clear_inputs)
        self.edit_menu.addAction(self.act_clear)

        self.act_copy_results = QAction("Copy Results", self)
        self.act_copy_results.setShortcut("Ctrl+C")
        self.act_copy_results.triggered.connect(self._edit_copy_results)
        self.edit_menu.addAction(self.act_copy_results)

        self.act_copy_report = QAction("Copy Report", self)
        self.act_copy_report.setShortcut("Ctrl+Shift+C")
        self.act_copy_report.triggered.connect(self._edit_copy_report)
        self.edit_menu.addAction(self.act_copy_report)

        self.edit_menu.addSeparator()

        self.act_export_plot = QAction("Export Plot…", self)
        self.act_export_plot.setShortcut("Ctrl+E")
        self.act_export_plot.triggered.connect(self._edit_export_plot)
        self.edit_menu.addAction(self.act_export_plot)

        # Initialize disabled; will be enabled per-widget
        self._refresh_edit_menu()

        # Help
        help_menu = menu_bar.addMenu("&Help")
        instruct_action = QAction("Instructions", self)
        instruct_action.setShortcut("F1")
        instruct_action.triggered.connect(self._show_instructions)
        help_menu.addAction(instruct_action)
        about_action = QAction("About Chemistry Suite", self)
        about_action.triggered.connect(self._show_about)
        help_menu.addAction(about_action)

    # --- Status bar ---
    def _setup_statusbar(self) -> None:
        self.status_bar = QStatusBar()
        self.setStatusBar(self.status_bar)
        self.status_bar.showMessage("Ready")

    # --- Navigation ---
    def _go_home(self) -> None:
        """Explicitly switch to the Home widget."""
        # Ensure the item is valid
        if hasattr(self, 'item_home') and self.item_home:
            self.sidebar.setCurrentItem(self.item_home)
            # Force the click handler even if it was already selected
            self._on_sidebar_click(self.item_home, 0)
            self.status_bar.showMessage("Opened: Home")
        else:
            trace("Home item not found in _go_home")

    def _handle_home_navigation(self, slug: str):
        """Handle navigation requests from the Home Page HTML."""
        target_title = SLUG_MAP.get(slug)
        if not target_title:
            warn(f"Unknown navigation slug: {slug}")
            return

        # Iterate through sidebar items to find the matching title
        iterator = QTreeWidgetItemIterator(self.sidebar)
        while iterator.value():
            item = iterator.value()
            # Compare with the visible label text
            if item.text(0) == target_title:
                self.sidebar.setCurrentItem(item)
                self._on_sidebar_click(item, 0)
                return
            iterator += 1

        warn(f"Could not find sidebar item for title: {target_title}")

    # --- Current widget helper ---
    def _current_widget(self) -> Optional[QWidget]:
        return self.content_stack.currentWidget()

    # --- Edit menu dispatchers ---
    def _edit_clear_inputs(self) -> None:
        w = self._current_widget()
        if w and hasattr(w, "clear_inputs"):
            try:
                w.clear_inputs()
            except Exception as e:
                trace(f"clear_inputs failed: {e}")

    def _edit_copy_results(self) -> None:
        w = self._current_widget()
        if w and hasattr(w, "copy_results"):
            try:
                w.copy_results()
            except Exception as e:
                trace(f"copy_results failed: {e}")

    def _edit_copy_report(self) -> None:
        w = self._current_widget()
        if w and hasattr(w, "copy_report"):
            try:
                w.copy_report()
            except Exception as e:
                trace(f"copy_report failed: {e}")

    def _edit_export_plot(self) -> None:
        w = self._current_widget()
        # Prefer an explicit export_plot() if present
        if w and hasattr(w, "export_plot"):
            try:
                w.export_plot()
            except Exception as e:
                trace(f"export_plot failed: {e}")
        else:
            # Graceful no-op (kept for consistency)
            warn("Export Plot is not available for this module.")

    def _refresh_edit_menu(self) -> None:
        """Enable/disable Edit actions based on the current widget's capabilities."""
        w = self._current_widget()
        has = lambda attr: (w is not None) and hasattr(w, attr)
        self.act_clear.setEnabled(has("clear_inputs"))
        self.act_copy_results.setEnabled(has("copy_results"))
        self.act_copy_report.setEnabled(has("copy_report"))
        self.act_export_plot.setEnabled(has("export_plot"))

    # --- Sidebar click handler (lazy instantiation) ---
    def _on_sidebar_click(self, item: QTreeWidgetItem, _column: int) -> None:
        key = item.data(0, Qt.ItemDataRole.UserRole)
        if not key or key not in self._registry:
            warn("Selected item has no registered factory.")
            return

        index = item.data(0, Qt.ItemDataRole.UserRole + 1)
        try:
            index = int(index)
        except Exception:
            index = -1

        # Create on first use
        if index < 0:
            factory, title = self._registry[key]
            try:
                widget = factory()
            except Exception as e:
                detail = f"Failed to load this module.\n\nError: {e}"
                trace(detail)
                widget = GenericPlaceholder(title, detail)

            # --- Connect navigation signal if it's the Home Page ---
            if isinstance(widget, HomePageWidget):
                widget.navigate_signal.connect(self._handle_home_navigation)

            index = self.content_stack.addWidget(widget)
            item.setData(0, Qt.ItemDataRole.UserRole + 1, index)

            # Ensure help page for this module (on-demand)
            self._ensure_widget_help_page(widget, title)

        # Show the page
        self.content_stack.setCurrentIndex(index)
        if hasattr(self, "status_bar"):
            self.status_bar.showMessage(f"Opened: {item.text(0)}")
        # Update Edit menu state for this widget
        self._refresh_edit_menu()

    # --- Help file resolution and showing ---
    def _resolve_help_filename(self, widget: QWidget, fallback_title: str) -> str:
        """
        Priority:
        1) BaseWidget.get_help_filename()
        2) widget.help_key -> <help_key>_inst.html
        3) widget.help_filename
        4) fallback based on title: '<title>_inst.html' (normalized)
        """
        # 1) BaseWidget standardized
        if isinstance(widget, BaseWidget):
            try:
                fname = widget.get_help_filename()
                if isinstance(fname, str) and fname.strip():
                    return fname
            except Exception as e:
                trace(f"BaseWidget.get_help_filename failed: {e}")

        # 2) help_key
        if hasattr(widget, "help_key"):
            key = getattr(widget, "help_key")
            if isinstance(key, str) and key.strip():
                return f"{key}_inst.html"

        # 3) legacy attribute
        if hasattr(widget, "help_filename"):
            hf = getattr(widget, "help_filename")
            if isinstance(hf, str) and hf.strip():
                return hf

        # 4) normalized fallback from title
        key = fallback_title.lower().replace(" ", "_")
        return f"{key}_inst.html"

    def _ensure_widget_help_page(self, widget: QWidget, title: str) -> None:
        """Create a placeholder help page for the widget if missing."""
        filename = self._resolve_help_filename(widget, title)
        ensure_instruction_page(INSTRUCTIONS_DIR, filename, title)

    def _show_instructions(self) -> None:
        current_widget = self.content_stack.currentWidget()
        if current_widget is None:
            warn("No active widget to show instructions for.")
            return

        # Title from current selection if possible
        current_item = self.sidebar.currentItem()
        title_guess = None
        if current_item is not None:
            key = current_item.data(0, Qt.ItemDataRole.UserRole)
            if key and key in self._registry:
                title_guess = self._registry[key][1]
        if not title_guess:
            title_guess = "Chemistry Suite"

        help_file = self._resolve_help_filename(current_widget, title_guess)
        file_path = os.path.join(INSTRUCTIONS_DIR, help_file)

        # Ensure existence (placeholder if missing)
        ensure_instruction_page(INSTRUCTIONS_DIR, help_file, title_guess)

        # Load HTML (fallback string)
        content = ""
        try:
            with open(file_path, "r", encoding="utf-8") as f:
                content = f.read()
        except Exception as e:
            content = f"<h3>Error loading instructions</h3><p>{e}</p>"

        if self.help_window is None:
            # Pass both content and file_path; dialog will prefer WebEngine if available and preferred
            self.help_window = HelpViewerDialog(content, file_path, self)
            self.help_window.show()
        else:
            self.help_window.set_content(content, file_path)
            self.help_window.show()
            self.help_window.raise_()
            self.help_window.activateWindow()

    # --- About dialog ---
    def _show_about(self) -> None:
        QMessageBox.about(
            self,
            "About Chemistry Suite",
            "<h3>Chemistry Suite</h3>"
            "<p>Version 0.1.8 (Beta)</p>"
            "<p><b>Developer:</b> Alvaro Etcheverry Berrios</p>"
            "<p>A modular suite of tools for chemical data and calculations.</p>",
        )

    # --- Preferences ---
    def _show_preferences(self) -> None:
        dlg = PreferencesDialog(self)
        dlg.exec()
        # After dialog closes, ensure status message refresh
        self.status_bar.showMessage("Preferences updated")

    # --- Exit (respect confirm preference) ---
    def _on_exit(self):
        confirm = getattr(QApplication.instance(), "_confirm_exit", False)
        if confirm:
            ret = QMessageBox.question(self, "Exit", "Are you sure you want to exit Chemistry Suite?")
            if ret != QMessageBox.StandardButton.Yes:
                return
        self.close()


# --- Loading screen (non-blocking startup) ---
class LoadingScreen(QWidget):
    def __init__(self, parent: Optional[QWidget] = None) -> None:
        super().__init__(parent, Qt.WindowType.WindowStaysOnTopHint)
        self.setWindowFlag(Qt.WindowType.FramelessWindowHint, True)
        self.setFixedSize(480, 300)
        v = QVBoxLayout(self)
        v.setContentsMargins(24, 24, 24, 24)
        v.setSpacing(12)
        container = QWidget(self)
        inner = QVBoxLayout(container)
        inner.setContentsMargins(24, 24, 24, 24)
        inner.setSpacing(10)
        icon_label = QLabel(container)
        icon_path = os.path.join(RESOURCES_DIR, "icon.ico")
        if os.path.exists(icon_path):
            icon_pix = QIcon(icon_path).pixmap(128, 128)
            if not icon_pix.isNull():
                icon_label.setPixmap(icon_pix)
        icon_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        inner.addWidget(icon_label)
        title = QLabel("Chemistry Suite", container)
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        inner.addWidget(title)
        subtitle = QLabel("Loading...", container)  # ASCII ellipsis avoids mojibake
        subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        inner.addWidget(subtitle)
        progress = QProgressBar(container)
        progress.setRange(0, 0)
        progress.setTextVisible(False)
        progress.setFixedHeight(12)
        inner.addWidget(progress)
        inner.addStretch()
        v.addWidget(container)
        screen_geo = QApplication.primaryScreen().availableGeometry()
        self.move(screen_geo.center() - self.rect().center())


# --- Entry point ---
if __name__ == "__main__":
    # If WebEngine is available, set AA_ShareOpenGLContexts BEFORE creating QApplication
    try:
        if WEBENGINE_AVAILABLE:
            QGuiApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts)
    except Exception as e:
        trace(f"Failed to set AA_ShareOpenGLContexts: {e}")

    app = QApplication(sys.argv)

    # Preferences at startup
    pref = PreferencesManager()
    pref.apply_runtime_flags(app)
    pref.apply_theme(app)
    pref.snapshot_baseline_font(app)
    pref.compute_and_store_font_baseline(app)
    pref.apply_font_size(app)

    # Loading screen preference
    show_loading = bool(pref.get(PrefKeys.SHOW_LOADING))

    if show_loading:
        loading = LoadingScreen()
        loading.show()
        app.processEvents()

    # Hold a reference to the window to prevent premature GC
    window: Optional[ChemistrySuiteApp] = None

    def start_main() -> None:
        global window
        window = ChemistrySuiteApp()
        window.show()
        if show_loading:
            loading.close()

    # Non-blocking startup
    QTimer.singleShot(0, start_main)
    sys.exit(app.exec())